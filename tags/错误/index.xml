<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>错误 on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/tags/%E9%94%99%E8%AF%AF/</link>
    <description>Recent content in 错误 on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <atom:link href="http://blog.wenzhixin.net.cn/tags/%E9%94%99%E8%AF%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>chrome 浏览器 console 面板直接使用 JSON 数据进行调试错误问题</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/chrome_console_error</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/chrome_console_error</guid>
      <description>&lt;p&gt;今天在微博上看到小鱼在问：&lt;a href=&#34;https://gist.github.com/sofish/c250881989aaa10c029d&#34;&gt;https://gist.github.com/sofish/c250881989aaa10c029d&lt;/a&gt; 为什么会出错，看了下之前就有遇到过这个问题，特意整理记录下。&lt;/p&gt;

&lt;p&gt;是想直接 copy json 数据到 console 面板进行调试，但是竟然报错了。然后特意对比了下，奇怪的是为什么 &lt;code&gt;{a: &amp;quot;b&amp;quot;}&lt;/code&gt; 是输出 &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;，而 &lt;code&gt;{&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;}&lt;/code&gt; 输出却是 &lt;code&gt;Uncaught SyntaxError: Unexpected token :&lt;/code&gt;，why?&lt;/p&gt;

&lt;p&gt;后面就研究了下，可以看到源码 &lt;a href=&#34;https://code.google.com/p/webkit-mirror/source/browse/Source/WebCore/inspector/InjectedScriptSource.js?r=ed19c0a99ddb564e317bb7363d481c2693ffb5fd#333&#34;&gt;InjectedScriptSource.js&lt;/a&gt; 中实现 console 是通过下面的方式：&lt;/p&gt;
expression = &#34;with ((window &amp;&amp; window.console &amp;&amp; window.console._commandLineAPI) || {}) {\n&#34; + expression + &#34;\n}&#34;;
eval(expression);

&lt;p&gt;当我们在 &lt;code&gt;console&lt;/code&gt; 面板下直接输入 &lt;code&gt;{a: &amp;quot;b&amp;quot;}&lt;/code&gt; 时，相当于执行：&lt;/p&gt;
eval(&#34;with ((window &amp;&amp; window.console &amp;&amp; window.console._commandLineAPI) || {}) {\n{a: \&#34;b\&#34;}\n}&#34;); // &#34;b&#34;

&lt;p&gt;而 &lt;code&gt;{&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;}&lt;/code&gt; 相当于执行：&lt;/p&gt;
eval(&#34;with ((window &amp;&amp; window.console &amp;&amp; window.console._commandLineAPI) || {}) {\n{\&#34;a\&#34;: \&#34;b\&#34;}\n}&#34;); // Uncaught SyntaxError: Unexpected token :

&lt;p&gt;因为 &lt;code&gt;with&lt;/code&gt; 这里的 &lt;code&gt;{{ ... }}&lt;/code&gt; 被忽略成了 &lt;code&gt;{}&lt;/code&gt;，例如：&lt;/p&gt;
with (window) {{{{a:&#34;b&#34;}}}}; // window.a = &#34;b&#34;;

with (window) {&#34;a&#34;:&#34;b&#34;}; // error!!!

&lt;p&gt;后面想直接 copy json 到 console 中进行调试的时候，加上：&lt;/p&gt;
var obj = {&#34;status&#34;:&#34;error&#34;,&#34;error&#34;:{&#34;msg&#34;:&#34;\u6b64\u997f\u5355\u5df2\u6295\u8bc9&#34;,&#34;code&#34;:23}}; // undefined

&lt;p&gt;就OK了，但是这样还得输入多一次 obj，干脆酱紫：&lt;/p&gt;
}0,{&#34;status&#34;:&#34;error&#34;,&#34;error&#34;:{&#34;msg&#34;:&#34;\u6b64\u997f\u5355\u5df2\u6295\u8bc9&#34;,&#34;code&#34;:23} // Object {status: &#34;error&#34;, error: Object}

&lt;p&gt;还有其他的一些比较有趣的，例如输入：&lt;/p&gt;
{} // undefined

( // Uncaught SyntaxError: Unexpected token }

}{ // undefined

}!{ // false

}!!{ // true

}+{ // NaN
</description>
    </item>
    
    <item>
      <title>在 Backbone.js 中自定义 fetch 错误处理</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/backbone_custom_fetch_errors</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/backbone_custom_fetch_errors</guid>
      <description>&lt;p&gt;Backbone 作为 JavaScript MVC 框架的一个优势是它可以通过监听事件来处理事情。但是根据 Collection 的相关&lt;a href=&#34;http://backbonejs.org/#Collection&#34;&gt;文档&lt;/a&gt;，可以看到：当你使用&lt;code&gt;fetch&lt;/code&gt;方法来进行 Ajax 请求的时候，假如发生了错误，并没有触发任何事件。虽然，可以通过&lt;code&gt;collection.fetch({error: handleError});&lt;/code&gt;的方法来处理错误，但是假如我们的 Collection 一多，那就不太好办了，很难做到统一处理错误，并且每个地方都要加上对错误的处理。&lt;/p&gt;

&lt;p&gt;查看 fetch 的源码：&lt;/p&gt;
fetch: function(options) {
  options = options ? _.clone(options) : {};
  if (options.parse === void 0) options.parse = true;
  var success = options.success;
  var collection = this;
  options.success = function(resp) {
    var method = options.reset ? &#39;reset&#39; : &#39;set&#39;;
    collection[method](resp, options);
    if (success) success(collection, resp, options);
    collection.trigger(&#39;sync&#39;, collection, resp, options);
  };
  wrapError(this, options);
  return this.sync(&#39;read&#39;, this, options);
}

&lt;p&gt;我们可以通过修改这一方法，从而达到自定义错误处理的效果，代码如下：&lt;/p&gt;
var appView = new AppView(),
    fetch = Backbone.Collection.prototype.fetch;

Backbone.Collection.prototype.fetch = function(options) {
    var self = this,
        opts = {
            error: function(collection, res) {
                self.trigger(&#39;fetch.error&#39;);　// trigger custom event
                if (options &amp;&amp; options.error) {
                    options.error(arguments);
                    return;
                }
                if (res.status === 401) {
                    appView.showLogin();
                } else {
                    appView.showError(res.status);
                }
            }
        };

    // Combine options and custom handlers, apply to fetch prototype.
    (_.bind(fetch, this, _.extend({}, options, opts)))();
};

&lt;p&gt;可以看到我们重写了&lt;code&gt;Backbone.Collection.prototype.fetch&lt;/code&gt;方法，并自定义了&lt;code&gt;fetch.error&lt;/code&gt;事件，方便进行监听处理。最重要的是我们不用修改之前的任何代码，在这里对错误进行了统一的处理，当&lt;code&gt;status code&lt;/code&gt;为 401 时，我们跳转到登录页面，其他则显示错误信息。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>