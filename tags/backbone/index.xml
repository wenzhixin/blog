<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backbone on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/tags/backbone/</link>
    <description>Recent content in Backbone on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <lastBuildDate>Sat, 14 Jun 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.wenzhixin.net.cn/tags/backbone/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在 Backbone.js 中自定义 fetch 错误处理</title>
      <link>http://blog.wenzhixin.net.cn/2014/06/14/backbone_custom_fetch_errors</link>
      <pubDate>Sat, 14 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/06/14/backbone_custom_fetch_errors</guid>
      <description>&lt;p&gt;Backbone 作为 JavaScript MVC 框架的一个优势是它可以通过监听事件来处理事情。但是根据 Collection 的相关&lt;a href=&#34;http://backbonejs.org/#Collection&#34;&gt;文档&lt;/a&gt;，可以看到：当你使用&lt;code&gt;fetch&lt;/code&gt;方法来进行 Ajax 请求的时候，假如发生了错误，并没有触发任何事件。虽然，可以通过&lt;code&gt;collection.fetch({error: handleError});&lt;/code&gt;的方法来处理错误，但是假如我们的 Collection 一多，那就不太好办了，很难做到统一处理错误，并且每个地方都要加上对错误的处理。&lt;/p&gt;

&lt;p&gt;查看 fetch 的源码：&lt;/p&gt;
fetch: function(options) {
  options = options ? _.clone(options) : {};
  if (options.parse === void 0) options.parse = true;
  var success = options.success;
  var collection = this;
  options.success = function(resp) {
    var method = options.reset ? &#39;reset&#39; : &#39;set&#39;;
    collection[method](resp, options);
    if (success) success(collection, resp, options);
    collection.trigger(&#39;sync&#39;, collection, resp, options);
  };
  wrapError(this, options);
  return this.sync(&#39;read&#39;, this, options);
}

&lt;p&gt;我们可以通过修改这一方法，从而达到自定义错误处理的效果，代码如下：&lt;/p&gt;
var appView = new AppView(),
    fetch = Backbone.Collection.prototype.fetch;

Backbone.Collection.prototype.fetch = function(options) {
    var self = this,
        opts = {
            error: function(collection, res) {
                self.trigger(&#39;fetch.error&#39;);　// trigger custom event
                if (options &amp;&amp; options.error) {
                    options.error(arguments);
                    return;
                }
                if (res.status === 401) {
                    appView.showLogin();
                } else {
                    appView.showError(res.status);
                }
            }
        };

    // Combine options and custom handlers, apply to fetch prototype.
    (_.bind(fetch, this, _.extend({}, options, opts)))();
};

&lt;p&gt;可以看到我们重写了&lt;code&gt;Backbone.Collection.prototype.fetch&lt;/code&gt;方法，并自定义了&lt;code&gt;fetch.error&lt;/code&gt;事件，方便进行监听处理。最重要的是我们不用修改之前的任何代码，在这里对错误进行了统一的处理，当&lt;code&gt;status code&lt;/code&gt;为 401 时，我们跳转到登录页面，其他则显示错误信息。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>