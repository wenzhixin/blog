<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>递归 on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/tags/%E9%80%92%E5%BD%92/</link>
    <description>Recent content in 递归 on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <lastBuildDate>Sat, 26 Oct 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.wenzhixin.net.cn/tags/%E9%80%92%E5%BD%92/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>nodejs 异步递归</title>
      <link>http://blog.wenzhixin.net.cn/2013/10/26/nodejs_async</link>
      <pubDate>Sat, 26 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/10/26/nodejs_async</guid>
      <description>

&lt;p&gt;今天继续之前的下载服务器的开发，第一步调用文件的 API 已经成功了，那么今天的目标是列出应用目录下的所有文件（包括子目录）。&lt;/p&gt;

&lt;h4 id=&#34;1-最初代码实现:5820bbca8bbfa97021cb736ac8a5bf26&#34;&gt;1. 最初代码实现&lt;/h4&gt;

&lt;p&gt;代码的实现主要是用到了异步回调+递归：&lt;/p&gt;
var https = require(&#39;https&#39;),
    config = require(&#39;./config&#39;),

    list = [];

function getList(path) {
    https.get(config.file_url + &#39;list&amp;access_token=&#39; + config.access_token + &#39;&amp;path=&#39; + path, function(res) {
        var content = &#39;&#39;;

        res.setEncoding(&#39;utf8&#39;);
        res.on(&#39;data&#39;, function(data) {
            content += data;
        });
        res.on(&#39;end&#39;, function() {
            var result = JSON.parse(content);
            result.list.forEach(function(item) {
                if (item.isdir === 1) { // 判断是否为目录
                    getList(item.path, callback);
                } else {
                    console.log(item.path);
                    list.push(item.path);
                    // handle(list); // 完成处理 list
                }
            });
        });
    });
}

getList(config.app_path);

&lt;p&gt;到这里，貌似已经可以获取所有的文件的。
但是发现了一个问题，那就是什么时候才完成所有的调用，然后对 list 进行下一步的处理呢？
因为 https.get() 是一个异步的方法，我们无法知道什么时候完成。&lt;/p&gt;

&lt;h4 id=&#34;2-async-each-和-async-eachseries-的实现:5820bbca8bbfa97021cb736ac8a5bf26&#34;&gt;2. async.each 和 async.eachSeries 的实现&lt;/h4&gt;

&lt;p&gt;相信聪明的人已经知道怎么解决上面的问题了，但是我并不聪明，一时半会被卡在了这里。
记得之前刚刚看过《JavaScript 异步编程》这本书，里面有提到 &lt;a href=&#34;https://github.com/caolan/async&#34;&gt;async&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/creationix/step&#34;&gt;step&lt;/a&gt;。
其实有用过了 async 了，但是一直是时间去研究源码，既然自己遇到了问题，那不搞懂也不能罢休。&lt;/p&gt;

&lt;p&gt;修改了下，实现很简单：&lt;/p&gt;
function each(arr, iterator, callback) {
    callback = callback || function () {};
    if (!arr.length) {
        return callback();
    }
    var completed = 0;
    arr.forEach(function (x) {
        iterator(x, function (err) {
            if (err) {
                callback(err);
                callback = function () {};
            }
            else {
                completed += 1;
                if (completed &gt;= arr.length) {
                    callback(null);
                }
            }
        });
    });
};

function eachSeries(arr, iterator, callback) {
    callback = callback || function () {};
    if (!arr.length) {
        return callback();
    }
    var completed = 0;
    var iterate = function () {
        iterator(arr[completed], function (err) {
            if (err) {
                callback(err);
                callback = function () {};
            }
            else {
                completed += 1;
                if (completed &gt;= arr.length) {
                    callback(null);
                }
                else {
                    iterate();
                }
            }
        });
    };
    iterate();
};

&lt;p&gt;其实也不难理解，加了 completed 参数统计完成的数量，两个函数都有 callback 作为结束的函数通知。
有所不同的是 eachSeries 的话是在一次异步请求返回之后才进行下一个请求，这样就相当于实现了同步调用。&lt;/p&gt;

&lt;h4 id=&#34;3-最终成果:5820bbca8bbfa97021cb736ac8a5bf26&#34;&gt;3. 最终成果&lt;/h4&gt;
var https = require(&#39;https&#39;),
    config = require(&#39;./config&#39;),

    list = [];

function getList(path, callback) {
    https.get(config.file_url + &#39;list&amp;access_token=&#39; + config.access_token + &#39;&amp;path=&#39; + path, function(res) {
        var content = &#39;&#39;;

        res.setEncoding(&#39;utf8&#39;);
        res.on(&#39;data&#39;, function(data) {
            content += data;
        });
        res.on(&#39;end&#39;, function() {
            var result = JSON.parse(content);
            each(result.list, function(item, callback) {
                if (item.isdir === 1) {
                    getList(item.path, callback);
                } else {
                    list.push(item.path);
                    callback();
                }
            }, function(err) {
                callback();
            });
        });
    });
}

getList(config.app_path, function() {
    list.forEach(function(path) {
        console.log(config.file_url + &#39;download&amp;access_token=&#39; + config.access_token + &#39;&amp;path=&#39; + path);
    });
});
</description>
    </item>
    
  </channel>
</rss>