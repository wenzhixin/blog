<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Extend on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/tags/extend/</link>
    <description>Recent content in Extend on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <lastBuildDate>Fri, 17 Jan 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.wenzhixin.net.cn/tags/extend/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>详解 jQuery.extend() 方法</title>
      <link>http://blog.wenzhixin.net.cn/2014/01/17/jquery_extend</link>
      <pubDate>Fri, 17 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/01/17/jquery_extend</guid>
      <description>&lt;p&gt;今天在写插件，使用&lt;code&gt;$.extend({}, defaults, options)&lt;/code&gt;的时候发现漏写了 {}，浪费了一些时间，
所以详细记录下该方法的 API 和使用。&lt;/p&gt;

&lt;p&gt;API 如下：&lt;/p&gt;

&lt;p&gt;jQuery.extend(  [ deep ], target, [ object1 ], [ objectN ] )&lt;/p&gt;

&lt;p&gt;描述：合并两个或更多的对象的内容汇集成到第一个对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;deep：如果是true，合并成为递归（又叫做深拷贝）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;target：一个对象，如果附加的对象被传递给这个方法将那么它将接收新的属性，如果它是唯一的参数将扩展 jQuery 的命名空间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object1：一个对象，它包含额外的属性合并到第一个参数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;objectN：包含额外的属性合并到第一个参数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码如下：&lt;/p&gt;
jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === &#34;boolean&#34; ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== &#34;object&#34; &amp;&amp; !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i &lt; length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we&#39;re merging plain objects or arrays
				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

					} else {
						clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don&#39;t bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

&lt;p&gt;关键代码为：&lt;/p&gt;
for ( name in options ) {
    src = target[ name ];
    copy = options[ name ];
    if ( deep ) {
        clone = src;
        target[ name ] = jQuery.extend( deep, clone, copy );
    } else {
        target[ name ] = copy;
    }
}

&lt;p&gt;假如 deep 为&lt;code&gt;true&lt;/code&gt;，则递归调用 extend 函数，从而实现深度拷贝。&lt;/p&gt;

&lt;p&gt;当我们提供两个或多个对象给$.extend()，对象的所有属性都添加到目标对象。&lt;/p&gt;

&lt;p&gt;通过代码可以看到目标对象（第一个参数）将被修改，也将通过 $.extend() 返回。&lt;/p&gt;

&lt;p&gt;如果我们想保留原对象，我们可以通过传递一个空对象作为目标：&lt;/p&gt;
var object = $.extend({}, object1, object2);
</description>
    </item>
    
  </channel>
</rss>