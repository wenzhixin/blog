<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/tags/javascript/</link>
    <description>Recent content in JavaScript on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <atom:link href="http://blog.wenzhixin.net.cn/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript 高级程序设计——变量、作用域和垃圾回收</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_variables_scope_and_garbage_collection</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_variables_scope_and_garbage_collection</guid>
      <description>&lt;p&gt;1、变量包含两种不同类型的值：基本类型值和引用类型值。基本类型值是指保存在栈内存中的简单数据段，即完全保存在内存中的一个位置。引用类型值是指保存在堆内存中的对象，即变量中保存的实际上只是一个指针，这个指针指向内存的另一个保存对象的位置。&lt;/p&gt;

&lt;p&gt;（1）对于基本类型值的变量，是按值访问的；对于引用类型值，首先从栈中读取内存地址，找到保存在堆中的值，即按引用访问。&lt;/p&gt;

&lt;p&gt;（2）基本类型值不能动态添加属性；引用类型值可以动态的添加属性。&lt;/p&gt;

&lt;p&gt;（3）在复制变量值时，基本类型值是复制一个具体的值，在改变其中一个变量的时候，不会影响另一个变量；引用类型值是复制一个引用，在改变其中一个变量的时候，会影响另一个变量。&lt;/p&gt;

&lt;p&gt;（4）检测一个变量的类型，使用 typeof 操作符和 instanceof 操作符，typeof
用于基本类型值，instanceof 用于引用类型值：variable instanceof constructor
//true or false&lt;/p&gt;

&lt;p&gt;2、执行环境和作用域&lt;/p&gt;

&lt;p&gt;（1）执行环境（execution
context）定义了变量或函数有权访问的数据，即变量对象（variable
object）。执行环境包括全局执行环境和局部执行环境。&lt;/p&gt;

&lt;p&gt;（2）当代码在执行环境中运行时，会创建由对象构成的一个作用域链（scope
chain）。作用域连是保证对执行环境有权访问的所有变量和函数的有序访问。当执行环境为全局执行环境时，作用域链是当前全局的变量对象；当执行环境为局部执行环境（函数）时，作用域链的变量对象只包含一个变量，即
arguments 对象。&lt;/p&gt;

&lt;p&gt;（3）使用 try-catch 语句的 catch 块以及 with 语句，都能延长作用域链。&lt;/p&gt;

&lt;p&gt;（4）JavaScript 中没有块级作用域，如：&lt;/p&gt;
if (true) {
  var test = &#34;test&#34;;

}
alert(test); //test

&lt;p&gt;3、垃圾回收机制&lt;/p&gt;

&lt;p&gt;（1）类型：主要包括标记清除（mark-and-sweep）和引用计数（reference
counting）。JavaScript 使用的垃圾回收机制都是标记清楚，而 IE 中的 COM
对象使用的是引用计数。&lt;/p&gt;

&lt;p&gt;（2）工作方式：如果垃圾收集例程回收的内存分配量低于
15%，则变量、字面量和数组元素的临界值就会加倍；如果例程回收了 85%
的内存分配量，则将各种临界值重置为默认值。&lt;/p&gt;

&lt;p&gt;（3）解除引用：执行中的代码只保存必要的数据，一旦数据不再使用，便将其值设置为
null 来释放其引用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——变量、作用域和垃圾回收</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_variables_scope_and_garbage_collection</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_variables_scope_and_garbage_collection</guid>
      <description>&lt;p&gt;1、变量包含两种不同类型的值：基本类型值和引用类型值。基本类型值是指保存在栈内存中的简单数据段，即完全保存在内存中的一个位置。引用类型值是指保存在堆内存中的对象，即变量中保存的实际上只是一个指针，这个指针指向内存的另一个保存对象的位置。&lt;/p&gt;

&lt;p&gt;（1）对于基本类型值的变量，是按值访问的；对于引用类型值，首先从栈中读取内存地址，找到保存在堆中的值，即按引用访问。&lt;/p&gt;

&lt;p&gt;（2）基本类型值不能动态添加属性；引用类型值可以动态的添加属性。&lt;/p&gt;

&lt;p&gt;（3）在复制变量值时，基本类型值是复制一个具体的值，在改变其中一个变量的时候，不会影响另一个变量；引用类型值是复制一个引用，在改变其中一个变量的时候，会影响另一个变量。&lt;/p&gt;

&lt;p&gt;（4）检测一个变量的类型，使用 typeof 操作符和 instanceof 操作符，typeof
用于基本类型值，instanceof 用于引用类型值：variable instanceof constructor
//true or false&lt;/p&gt;

&lt;p&gt;2、执行环境和作用域&lt;/p&gt;

&lt;p&gt;（1）执行环境（execution
context）定义了变量或函数有权访问的数据，即变量对象（variable
object）。执行环境包括全局执行环境和局部执行环境。&lt;/p&gt;

&lt;p&gt;（2）当代码在执行环境中运行时，会创建由对象构成的一个作用域链（scope
chain）。作用域连是保证对执行环境有权访问的所有变量和函数的有序访问。当执行环境为全局执行环境时，作用域链是当前全局的变量对象；当执行环境为局部执行环境（函数）时，作用域链的变量对象只包含一个变量，即
arguments 对象。&lt;/p&gt;

&lt;p&gt;（3）使用 try-catch 语句的 catch 块以及 with 语句，都能延长作用域链。&lt;/p&gt;

&lt;p&gt;（4）JavaScript 中没有块级作用域，如：&lt;/p&gt;
if (true) {
  var test = &#34;test&#34;;

}
alert(test); //test

&lt;p&gt;3、垃圾回收机制&lt;/p&gt;

&lt;p&gt;（1）类型：主要包括标记清除（mark-and-sweep）和引用计数（reference
counting）。JavaScript 使用的垃圾回收机制都是标记清楚，而 IE 中的 COM
对象使用的是引用计数。&lt;/p&gt;

&lt;p&gt;（2）工作方式：如果垃圾收集例程回收的内存分配量低于
15%，则变量、字面量和数组元素的临界值就会加倍；如果例程回收了 85%
的内存分配量，则将各种临界值重置为默认值。&lt;/p&gt;

&lt;p&gt;（3）解除引用：执行中的代码只保存必要的数据，一旦数据不再使用，便将其值设置为
null 来释放其引用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——引用类型（Object、Array、String、Date）</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_object_array_string_date</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_object_array_string_date</guid>
      <description>&lt;p&gt;一、Object 类型&lt;/p&gt;

&lt;p&gt;1、创建 Object 实例的方法：使用 new 操作符接构造函数方法 和
使用对象字面量表示法。&lt;/p&gt;
var obj = new Object();
obj.name1 = value1;
obj.name2 = value2;
...
var obj = {
	name1: value1,
	name2: value2,
	...
}

&lt;p&gt;2、访问 Object
属性使用的方法：点表示法（优先使用）和方括号表示法（变量作为属性）。&lt;/p&gt;

&lt;p&gt; * obj.name&lt;/p&gt;

&lt;p&gt; * obj[&amp;ldquo;name&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;3、常用方法：&lt;/p&gt;

&lt;p&gt;（1）obj.hasOwnProperty(name)-判断 obj 对象是否存在 name 属性，例子：&lt;/p&gt;
var obj = {name: &#34;wenyi&#34;};
alert(obj.hasOwnProperty(&#34;name&#34;));//true
alert(obj.hasOwnProperty(&#34;age&#34;));//false

&lt;p&gt;（2）Object.getOwnPropertyNames(obj)-获取 obj
对象中所有的属性名称，常用于对对象属性进行遍历，返回属性数组。例子：&lt;/p&gt;
var obj = {name: &#34;wenyi&#34;, age: 25};
var names = Object.getOwnPropertyNames(obj);
alert(names);//&#34;name,age&#34;

&lt;p&gt;二、Array 类型&lt;/p&gt;

&lt;p&gt;1、创建数组的方法：new Array 方法 和 使用数组字面量方法。&lt;/p&gt;
var arr = new Array();

var arr = new Array(length);

var arr = new Array(value1, value2, ...);
var arr = [value1, value2, ...];

&lt;p&gt;2、使用数组的方法：用方括号并提供响应值的机遇 0 的数字索引。&lt;/p&gt;

&lt;p&gt;3、数组的常用属性：&lt;/p&gt;

&lt;p&gt; * length-表示数组的长度，可以写入，表示设置数组的长度为指定大小。&lt;/p&gt;

&lt;p&gt;4、方法：&lt;/p&gt;

&lt;p&gt;（1）转换方法：toLocalString()、toString()、valueOf()和 join()。&lt;/p&gt;

&lt;p&gt; *
toLocalString()、toString()、valueOf()都会将数组中的每个值拼接成一个字符串，中间以逗号分割。&lt;/p&gt;

&lt;p&gt; * join()接收一个参数，用作分隔符，返回包含所以数组项的字符串。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
var colors = {&#34;red&#34;, &#34;blue&#34;, &#34;yellow&#34;};

alert(colors.toLocalString());//&#34;red,blue,yellow&#34;

alert(colors.toString());//&#34;red,blue,yellow&#34;

alert(colors.valueOf());//&#34;red,blue,yellow&#34;

alert(colors);//&#34;red,blue,yellow&#34;

alert(colors.join(&#34;|&#34;));//&#34;red|blue|yellow&#34;

&lt;p&gt;（2）栈（LIFO-后进先出）方法：push()和 pop()。&lt;/p&gt;

&lt;p&gt; *
push()可以接收任意数量的参数，逐个添加到数组末尾，返回修改后数组的长度。&lt;/p&gt;

&lt;p&gt; * pop()表示从数组末尾移除最后一项，返回移除的项。&lt;/p&gt;

&lt;p&gt;（3）队列（FIFO-先进先出）方法：push()和 shift()；unshift()和 pop()。&lt;/p&gt;

&lt;p&gt; * shift()表示移除并返回数组的第一个项。&lt;/p&gt;

&lt;p&gt; * unshift()表示在数组前端添加任意个项并返回修改后数组的长度。&lt;/p&gt;

&lt;p&gt;（4）重排序方法：reverse()和 sort()。&lt;/p&gt;

&lt;p&gt; * reverse()用于反转数组项的顺序。&lt;/p&gt;

&lt;p&gt; *
sort()用于对数组项进行字符串排序，默认按升序排列。对数值类型进行排序，需要传递比较函数，比较函数接收两个参数，返回负数表示第一个参数应该位于第二个之前，返回
0 表示两个参数相等，返回正数表示第一个参数应该位于第二个之后。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function compareAsc(value1, value2) {
	return value1 - value2;
}

function compareDesc(value1, value2) {
	return value2 - value1;
}

var values = {5, 0, 15, 10};

values.reverse();
alert(values);//10, 15, 0, 5

values = values.soft(compareAsc);
alert(values);//0, 5, 10, 15

values = values.soft(compareDesc);
alert(values);//15, 10, 5, 0

&lt;p&gt;（5）操作方法：concat()、slice()和 splice()。&lt;/p&gt;

&lt;p&gt; * concat()基于当前数组，将接收到的参数添加到末尾，并返回新构建的数组。&lt;/p&gt;

&lt;p&gt; *
slice()基于当前数组中的一个或者多个项来创建一个新数组，可以接收一个或两个参数，表示返回项的起始和结尾位置。&lt;/p&gt;

&lt;p&gt; *
splice()可用于删除、插入和替换多种操作。接收两个或两个以上的参数，第一个参数表示起始位置、第二个参数表示要删除的项数，第三个参数开始表示所有插入的项。&lt;/p&gt;

&lt;p&gt;三、String 类型&lt;/p&gt;

&lt;p&gt;1、字符方法：charAt()和
charCodeAt()，接收一个参数，返回指定位置的字符和字符编码。&lt;/p&gt;

&lt;p&gt;2、字符串操作方法：&lt;/p&gt;

&lt;p&gt; *
concat()：用于将一或多个字符串拼接起来，返回新字符串。注：实践中用的比较少，用加号操作符（+）代替。&lt;/p&gt;

&lt;p&gt; * slice(start, end)、substr(start, length)和 substring(start,
end)，用于基于子字符串创建新字符串的方法。&lt;/p&gt;

&lt;p&gt;3、字符串位置方法：indexOf()和
lastIndexOf()从一个字符串中搜索给定的子字符串，返回子字符串的位置。&lt;/p&gt;

&lt;p&gt;4、字符串模式匹配方法：&lt;/p&gt;

&lt;p&gt; * match()：接收一个参数，正则表达式或者是 RegExp 对象，返回匹配数组&lt;/p&gt;

&lt;p&gt; * search()：返回字符串中第一个匹配项的索引&lt;/p&gt;

&lt;p&gt; * replace()：接收两个参数，第一个参数为 正则表达式或者 RegExp
对象或者字符串，第二个参数为字符串或者函数。注：替换所有子字符串，需要提供一个正则表达式并指定全局（g）标志。&lt;/p&gt;

&lt;p&gt;四、Date 类型&lt;/p&gt;

&lt;p&gt;1、创建 Date 对象&lt;/p&gt;

&lt;p&gt; * Date()：表示创建一个当前日期对象&lt;/p&gt;

&lt;p&gt; * Date(dateStr) 和
Date.parse(dateStr)：表示接收一个表示日期的字符串参数，创建一个日期对象。（注：接收
yyyy/MM/dd 的格式，不接收 yyyy-mm-dd 格式）&lt;/p&gt;

&lt;p&gt; * Date(year, month, day, hour, minute, second) 和 Date.UTC(year,
month, day, hour, minute, second)：表示通过参数创建一个日期对象，year 和
month 为必须项。&lt;/p&gt;

&lt;p&gt; * 用于转换 yyyy-MM-dd hh-mm-ss 字符串格式的例子：&lt;/p&gt;
function parseDate(dateStr) {
	dateStr = dateStr.replace(/\\-/g, &#34;-&#34;);
	return new Date(dateStr);
}

var dateStr = &#34;2012-04-05 11:19:00&#34;;
var date = parseDate(dateStr);

&lt;p&gt;2、日期格式化方法：&lt;/p&gt;

&lt;p&gt; * toDateString()-显示星期几、月、年、日&lt;/p&gt;

&lt;p&gt; * toLocaleDateString()-显示特定地区的星期几、月、年、日&lt;/p&gt;

&lt;p&gt; * toTimeString()-显示时、分、秒和时区&lt;/p&gt;

&lt;p&gt; * toLocaleTimeString()-显示特定地区时、分、秒和时区&lt;/p&gt;

&lt;p&gt; * toUTCString()-显示完整的 UTC 日期&lt;/p&gt;

&lt;p&gt;3、日期/时间组件方法&lt;/p&gt;

&lt;p&gt; * getTime/setTime：日期毫秒数&lt;/p&gt;

&lt;p&gt; * getFullYear/setFullYear：4位数年份&lt;/p&gt;

&lt;p&gt; * getMonth/setMonth：日期中的月份，0-11&lt;/p&gt;

&lt;p&gt; * getDate/setDate：日期中的天数，1-31&lt;/p&gt;

&lt;p&gt; * getDay/setDay：日期中的星期数，0-6&lt;/p&gt;

&lt;p&gt; * getHours/setHours：日期中的小时数，0-23&lt;/p&gt;

&lt;p&gt; * getMinutes/setMinutes：日期中的分钟数，0-59&lt;/p&gt;

&lt;p&gt; * getSeconds/setSeconds：日期中的秒数，0-59&lt;/p&gt;

&lt;p&gt; * getMilliseconds/setMilliseconds：日期中的毫秒数&lt;/p&gt;

&lt;p&gt;五、Math 类型&lt;/p&gt;

&lt;p&gt;1、属性：&lt;/p&gt;

&lt;p&gt; * Math.E：常量 e 的值&lt;/p&gt;

&lt;p&gt; * Math.LN10：10 的自然对数&lt;/p&gt;

&lt;p&gt; * Math.LN2：2 的自然对数&lt;/p&gt;

&lt;p&gt; * Math.LOG2E：以 2 为底 e 的对数&lt;/p&gt;

&lt;p&gt; * Math.LOG10E：以 10 为底 e 的对数&lt;/p&gt;

&lt;p&gt; * Math.PI：pi的值&lt;/p&gt;

&lt;p&gt; * Math.SQRT1_2：1/2 的平方根&lt;/p&gt;

&lt;p&gt; * Math.SQRT2：2 的平方根&lt;/p&gt;

&lt;p&gt;2、方法：&lt;/p&gt;

&lt;p&gt; * min()和 max()确定数组中的最小值和最大值&lt;/p&gt;

&lt;p&gt; * ceil()、floor()和 round()执行向上舍入、向下舍入和标准舍入&lt;/p&gt;

&lt;p&gt; * random()返回介于 0-1 之间的一个随机数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——引用类型（Object、Array、String、Date）</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_object_array_string_date</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_object_array_string_date</guid>
      <description>&lt;p&gt;一、Object 类型&lt;/p&gt;

&lt;p&gt;1、创建 Object 实例的方法：使用 new 操作符接构造函数方法 和
使用对象字面量表示法。&lt;/p&gt;
var obj = new Object();
obj.name1 = value1;
obj.name2 = value2;
...
var obj = {
	name1: value1,
	name2: value2,
	...
}

&lt;p&gt;2、访问 Object
属性使用的方法：点表示法（优先使用）和方括号表示法（变量作为属性）。&lt;/p&gt;

&lt;p&gt; * obj.name&lt;/p&gt;

&lt;p&gt; * obj[&amp;ldquo;name&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;3、常用方法：&lt;/p&gt;

&lt;p&gt;（1）obj.hasOwnProperty(name)-判断 obj 对象是否存在 name 属性，例子：&lt;/p&gt;
var obj = {name: &#34;wenyi&#34;};
alert(obj.hasOwnProperty(&#34;name&#34;));//true
alert(obj.hasOwnProperty(&#34;age&#34;));//false

&lt;p&gt;（2）Object.getOwnPropertyNames(obj)-获取 obj
对象中所有的属性名称，常用于对对象属性进行遍历，返回属性数组。例子：&lt;/p&gt;
var obj = {name: &#34;wenyi&#34;, age: 25};
var names = Object.getOwnPropertyNames(obj);
alert(names);//&#34;name,age&#34;

&lt;p&gt;二、Array 类型&lt;/p&gt;

&lt;p&gt;1、创建数组的方法：new Array 方法 和 使用数组字面量方法。&lt;/p&gt;
var arr = new Array();

var arr = new Array(length);

var arr = new Array(value1, value2, ...);
var arr = [value1, value2, ...];

&lt;p&gt;2、使用数组的方法：用方括号并提供响应值的机遇 0 的数字索引。&lt;/p&gt;

&lt;p&gt;3、数组的常用属性：&lt;/p&gt;

&lt;p&gt; * length-表示数组的长度，可以写入，表示设置数组的长度为指定大小。&lt;/p&gt;

&lt;p&gt;4、方法：&lt;/p&gt;

&lt;p&gt;（1）转换方法：toLocalString()、toString()、valueOf()和 join()。&lt;/p&gt;

&lt;p&gt; *
toLocalString()、toString()、valueOf()都会将数组中的每个值拼接成一个字符串，中间以逗号分割。&lt;/p&gt;

&lt;p&gt; * join()接收一个参数，用作分隔符，返回包含所以数组项的字符串。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
var colors = {&#34;red&#34;, &#34;blue&#34;, &#34;yellow&#34;};

alert(colors.toLocalString());//&#34;red,blue,yellow&#34;

alert(colors.toString());//&#34;red,blue,yellow&#34;

alert(colors.valueOf());//&#34;red,blue,yellow&#34;

alert(colors);//&#34;red,blue,yellow&#34;

alert(colors.join(&#34;|&#34;));//&#34;red|blue|yellow&#34;

&lt;p&gt;（2）栈（LIFO-后进先出）方法：push()和 pop()。&lt;/p&gt;

&lt;p&gt; *
push()可以接收任意数量的参数，逐个添加到数组末尾，返回修改后数组的长度。&lt;/p&gt;

&lt;p&gt; * pop()表示从数组末尾移除最后一项，返回移除的项。&lt;/p&gt;

&lt;p&gt;（3）队列（FIFO-先进先出）方法：push()和 shift()；unshift()和 pop()。&lt;/p&gt;

&lt;p&gt; * shift()表示移除并返回数组的第一个项。&lt;/p&gt;

&lt;p&gt; * unshift()表示在数组前端添加任意个项并返回修改后数组的长度。&lt;/p&gt;

&lt;p&gt;（4）重排序方法：reverse()和 sort()。&lt;/p&gt;

&lt;p&gt; * reverse()用于反转数组项的顺序。&lt;/p&gt;

&lt;p&gt; *
sort()用于对数组项进行字符串排序，默认按升序排列。对数值类型进行排序，需要传递比较函数，比较函数接收两个参数，返回负数表示第一个参数应该位于第二个之前，返回
0 表示两个参数相等，返回正数表示第一个参数应该位于第二个之后。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function compareAsc(value1, value2) {
	return value1 - value2;
}

function compareDesc(value1, value2) {
	return value2 - value1;
}

var values = {5, 0, 15, 10};

values.reverse();
alert(values);//10, 15, 0, 5

values = values.soft(compareAsc);
alert(values);//0, 5, 10, 15

values = values.soft(compareDesc);
alert(values);//15, 10, 5, 0

&lt;p&gt;（5）操作方法：concat()、slice()和 splice()。&lt;/p&gt;

&lt;p&gt; * concat()基于当前数组，将接收到的参数添加到末尾，并返回新构建的数组。&lt;/p&gt;

&lt;p&gt; *
slice()基于当前数组中的一个或者多个项来创建一个新数组，可以接收一个或两个参数，表示返回项的起始和结尾位置。&lt;/p&gt;

&lt;p&gt; *
splice()可用于删除、插入和替换多种操作。接收两个或两个以上的参数，第一个参数表示起始位置、第二个参数表示要删除的项数，第三个参数开始表示所有插入的项。&lt;/p&gt;

&lt;p&gt;三、String 类型&lt;/p&gt;

&lt;p&gt;1、字符方法：charAt()和
charCodeAt()，接收一个参数，返回指定位置的字符和字符编码。&lt;/p&gt;

&lt;p&gt;2、字符串操作方法：&lt;/p&gt;

&lt;p&gt; *
concat()：用于将一或多个字符串拼接起来，返回新字符串。注：实践中用的比较少，用加号操作符（+）代替。&lt;/p&gt;

&lt;p&gt; * slice(start, end)、substr(start, length)和 substring(start,
end)，用于基于子字符串创建新字符串的方法。&lt;/p&gt;

&lt;p&gt;3、字符串位置方法：indexOf()和
lastIndexOf()从一个字符串中搜索给定的子字符串，返回子字符串的位置。&lt;/p&gt;

&lt;p&gt;4、字符串模式匹配方法：&lt;/p&gt;

&lt;p&gt; * match()：接收一个参数，正则表达式或者是 RegExp 对象，返回匹配数组&lt;/p&gt;

&lt;p&gt; * search()：返回字符串中第一个匹配项的索引&lt;/p&gt;

&lt;p&gt; * replace()：接收两个参数，第一个参数为 正则表达式或者 RegExp
对象或者字符串，第二个参数为字符串或者函数。注：替换所有子字符串，需要提供一个正则表达式并指定全局（g）标志。&lt;/p&gt;

&lt;p&gt;四、Date 类型&lt;/p&gt;

&lt;p&gt;1、创建 Date 对象&lt;/p&gt;

&lt;p&gt; * Date()：表示创建一个当前日期对象&lt;/p&gt;

&lt;p&gt; * Date(dateStr) 和
Date.parse(dateStr)：表示接收一个表示日期的字符串参数，创建一个日期对象。（注：接收
yyyy/MM/dd 的格式，不接收 yyyy-mm-dd 格式）&lt;/p&gt;

&lt;p&gt; * Date(year, month, day, hour, minute, second) 和 Date.UTC(year,
month, day, hour, minute, second)：表示通过参数创建一个日期对象，year 和
month 为必须项。&lt;/p&gt;

&lt;p&gt; * 用于转换 yyyy-MM-dd hh-mm-ss 字符串格式的例子：&lt;/p&gt;
function parseDate(dateStr) {
	dateStr = dateStr.replace(/\\-/g, &#34;-&#34;);
	return new Date(dateStr);
}

var dateStr = &#34;2012-04-05 11:19:00&#34;;
var date = parseDate(dateStr);

&lt;p&gt;2、日期格式化方法：&lt;/p&gt;

&lt;p&gt; * toDateString()-显示星期几、月、年、日&lt;/p&gt;

&lt;p&gt; * toLocaleDateString()-显示特定地区的星期几、月、年、日&lt;/p&gt;

&lt;p&gt; * toTimeString()-显示时、分、秒和时区&lt;/p&gt;

&lt;p&gt; * toLocaleTimeString()-显示特定地区时、分、秒和时区&lt;/p&gt;

&lt;p&gt; * toUTCString()-显示完整的 UTC 日期&lt;/p&gt;

&lt;p&gt;3、日期/时间组件方法&lt;/p&gt;

&lt;p&gt; * getTime/setTime：日期毫秒数&lt;/p&gt;

&lt;p&gt; * getFullYear/setFullYear：4位数年份&lt;/p&gt;

&lt;p&gt; * getMonth/setMonth：日期中的月份，0-11&lt;/p&gt;

&lt;p&gt; * getDate/setDate：日期中的天数，1-31&lt;/p&gt;

&lt;p&gt; * getDay/setDay：日期中的星期数，0-6&lt;/p&gt;

&lt;p&gt; * getHours/setHours：日期中的小时数，0-23&lt;/p&gt;

&lt;p&gt; * getMinutes/setMinutes：日期中的分钟数，0-59&lt;/p&gt;

&lt;p&gt; * getSeconds/setSeconds：日期中的秒数，0-59&lt;/p&gt;

&lt;p&gt; * getMilliseconds/setMilliseconds：日期中的毫秒数&lt;/p&gt;

&lt;p&gt;五、Math 类型&lt;/p&gt;

&lt;p&gt;1、属性：&lt;/p&gt;

&lt;p&gt; * Math.E：常量 e 的值&lt;/p&gt;

&lt;p&gt; * Math.LN10：10 的自然对数&lt;/p&gt;

&lt;p&gt; * Math.LN2：2 的自然对数&lt;/p&gt;

&lt;p&gt; * Math.LOG2E：以 2 为底 e 的对数&lt;/p&gt;

&lt;p&gt; * Math.LOG10E：以 10 为底 e 的对数&lt;/p&gt;

&lt;p&gt; * Math.PI：pi的值&lt;/p&gt;

&lt;p&gt; * Math.SQRT1_2：1/2 的平方根&lt;/p&gt;

&lt;p&gt; * Math.SQRT2：2 的平方根&lt;/p&gt;

&lt;p&gt;2、方法：&lt;/p&gt;

&lt;p&gt; * min()和 max()确定数组中的最小值和最大值&lt;/p&gt;

&lt;p&gt; * ceil()、floor()和 round()执行向上舍入、向下舍入和标准舍入&lt;/p&gt;

&lt;p&gt; * random()返回介于 0-1 之间的一个随机数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——引用类型（RegExp、Function、Global）</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_regexp_function_global</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_regexp_function_global</guid>
      <description>&lt;p&gt;一、RegExp 类型&lt;/p&gt;

&lt;p&gt;1、创建一个正则表达式&lt;/p&gt;

&lt;p&gt;（1）语法：&lt;/p&gt;
var expression = / pattern / flags;
var expression = new RegExp(pattern, flags);

&lt;p&gt;（2）模式（pattern）部分可以是任何简单或者复杂的正则表达式，包含字符类、限定符、分组、向前查找、以及反向引用。&lt;/p&gt;

&lt;p&gt;（3）可带有一个或多个标志（flags），匹配模式支持 3 个标志：&lt;/p&gt;

&lt;p&gt; *
g——表示全局（global）模式，即模式将应用与所有字符串，而非在发现第一个匹配时立即停止&lt;/p&gt;

&lt;p&gt; *
i——表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写&lt;/p&gt;

&lt;p&gt; *
m——表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项&lt;/p&gt;

&lt;p&gt;（4）模式中使用的所有元字符都必须转义，而使用 RegExp
构造函数，所有的元字符必须双重转义。&lt;/p&gt;

&lt;p&gt; * 元字符包括： ( [ { \ \^ \$ | ? * + . } ] ) &lt;/p&gt;

&lt;p&gt;2、RegExp 实例属性&lt;/p&gt;

&lt;p&gt; * global：布尔值，表示是否设置了 g 标志&lt;/p&gt;

&lt;p&gt; * ignoreCase：布尔值，表示是否设置了 i 标志&lt;/p&gt;

&lt;p&gt; * lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起&lt;/p&gt;

&lt;p&gt; * multiline：布尔值，表示是否设置了 m 标志&lt;/p&gt;

&lt;p&gt; * source：正则表达式的字符串表示&lt;/p&gt;

&lt;p&gt;3、RegExp 实例方法&lt;/p&gt;

&lt;p&gt; *
exec()：专为捕获组设计，接收一个参数，即要应用模式的字符串，返回第一个匹配项信息的数组或者没有匹配项的时候返回
null。返回的数组包含两个额外属性：index 和
input，分别表示匹配项在字符串中的位置和应用正则表达式的字符串。&lt;/p&gt;

&lt;p&gt; * test()：接收一个字符串参数，模式与该参数匹配返回 true，否则返回 false&lt;/p&gt;

&lt;p&gt;二、Function 类型&lt;/p&gt;

&lt;p&gt;1、函数实际上是对象，每个函数都是 Function
类型的实例，具有属性和方法，而函数名实际上是一个指向函数对象的指针，不会与具体的函数绑定。函数通常使用函数声明语法来定义，如：&lt;/p&gt;
function functionName() {}
var functionName = function() {}

&lt;p&gt;2、函数声明与函数表达式的区别：解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
alert(sum1(10, 10));//20
function sum1(num1, num2) {
	return num1 + num2;
}

alert(sum2(10, 10));//error
var sum2 = function(num1, num2) {
	return num1 + num2;
}

&lt;p&gt;3、作为值的函数：不仅可以像传递函数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。也可以从一个函数中返回另一个函数，这是极为有用的技术。&lt;/p&gt;

&lt;p&gt; * 要根据某个对象属性对数组进行排序的例子：&lt;/p&gt;
function createComparisonFunction(propertyName) {
	return function(object1, object2) {
		var value1 = object1[propertyName];
		var value2 = object2[propertyName];
		if (value1 &lt; value2) {
			return -1;
		}

		if (value1 &gt; value2) {
			return 1;
		}

		return 0;
	}
}

var data = [{name: &#34;wenyi&#34;, age: 25}, {name: &#34;l&#34;, age: 26}];
data.sort(createComparisonFunction(&#34;name&#34;));
alert(data[0].name);//&#34;l&#34;

data.sort(createComparisonFunction(&#34;age&#34;));
alert(data[0].name);//&#34;wenyi&#34;

&lt;p&gt;4、函数内部属性&lt;/p&gt;

&lt;p&gt; * arguments：一个类似数组对象，包含着传入函数中的所有参数。还有一个名叫
callee 的属性，该属性是一个指针，指向拥有这个 arguments
对象的函数，主要用于递归函数。如：&lt;/p&gt;
function factorial(num) {
	if (num &lt; 1) {
		return 1;
	}
	return num * arguments.callee(num - 1);
}

&lt;p&gt; * this：引用的是函数据以执行操作的对象，也就是说，this
是函数在执行时所处的作用域。注：函数的名字仅仅是一个包含指针的变量而已。如：&lt;/p&gt;
var name = &#34;window&#34;;
function sayName() {
	alert(this.name);
}

var person = {name: &#34;wenyi&#34;, sayName: sayName};
sayName();//&#34;window&#34;
person.sayName();//&#34;wenyi&#34;

&lt;p&gt;5、函数属性&lt;/p&gt;

&lt;p&gt; * length：表示函数希望接收的命名参数的个数&lt;/p&gt;

&lt;p&gt; * prototype： 保存函数所有实例方法的真是所在。&lt;/p&gt;

&lt;p&gt;6、函数方法：&lt;/p&gt;

&lt;p&gt;（1）apply()和
call()方法，都是在特定的作用于中调用函数，实际上等于设置函数体内 this
对象的值。apply()接收两个参数，第一个是运行函数的作用域，第二个是参数数组。call()除了传入运行函数的作用域之外，必须明确的传入每一个参数。如：&lt;/p&gt;
function sum(num1, num2) {
	return num1 + num2;
}

function applySum(num1, num2) {
	sum.apply(this, arguments);
}

alert(applySum(10, 10));//20
alert(sum.apply(this, [10, 10]));//20
alert(sum.call(this, 10, 10));//20

&lt;p&gt;（2）apply()和
call()方法能够扩充函数赖以运行的作用域，使得对象不需要与方法有任何耦合关系。如：&lt;/p&gt;
var name = &#34;window&#34;;
function sayName() {
	alert(this.name);
}

var person = {name: &#34;wenyi&#34;};
sayName.call(this);//&#34;window&#34;
sayName.call(person);//&#34;wenyi&#34;

&lt;p&gt;三、Global 对象&lt;/p&gt;

&lt;p&gt;1、URI 方法&lt;/p&gt;

&lt;p&gt; * encodeURI()：对 URI 中的空格进行编码，替换成 %20。&lt;/p&gt;

&lt;p&gt; * decodeURI()：对使用 encodeURI 方法进行编码的字符进行解码。&lt;/p&gt;

&lt;p&gt; * encodeURIComponent()：对 URI 中的所有非字母数字字符进行编码。&lt;/p&gt;

&lt;p&gt; * decodeURIComponent()：对使用 encodeURIComponent
方法进行编码的字符进行解码。&lt;/p&gt;

&lt;p&gt;2、eval()方法：完整的 JavaScript
解析器，接收一个参数，将传入的参数当作实际的 JavaScript
语句来解析，并把执行结果插入到原位置。能够解析代码字符串的能力非常强大，同时也非常危险。在使用
eval()时必须十分谨慎，防止恶意输入威胁安全的代码（代码注入）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——引用类型（RegExp、Function、Global）</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_regexp_function_global</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_reference_types_regexp_function_global</guid>
      <description>&lt;p&gt;一、RegExp 类型&lt;/p&gt;

&lt;p&gt;1、创建一个正则表达式&lt;/p&gt;

&lt;p&gt;（1）语法：&lt;/p&gt;
var expression = / pattern / flags;
var expression = new RegExp(pattern, flags);

&lt;p&gt;（2）模式（pattern）部分可以是任何简单或者复杂的正则表达式，包含字符类、限定符、分组、向前查找、以及反向引用。&lt;/p&gt;

&lt;p&gt;（3）可带有一个或多个标志（flags），匹配模式支持 3 个标志：&lt;/p&gt;

&lt;p&gt; *
g——表示全局（global）模式，即模式将应用与所有字符串，而非在发现第一个匹配时立即停止&lt;/p&gt;

&lt;p&gt; *
i——表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写&lt;/p&gt;

&lt;p&gt; *
m——表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项&lt;/p&gt;

&lt;p&gt;（4）模式中使用的所有元字符都必须转义，而使用 RegExp
构造函数，所有的元字符必须双重转义。&lt;/p&gt;

&lt;p&gt; * 元字符包括： ( [ { \ \^ \$ | ? * + . } ] ) &lt;/p&gt;

&lt;p&gt;2、RegExp 实例属性&lt;/p&gt;

&lt;p&gt; * global：布尔值，表示是否设置了 g 标志&lt;/p&gt;

&lt;p&gt; * ignoreCase：布尔值，表示是否设置了 i 标志&lt;/p&gt;

&lt;p&gt; * lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起&lt;/p&gt;

&lt;p&gt; * multiline：布尔值，表示是否设置了 m 标志&lt;/p&gt;

&lt;p&gt; * source：正则表达式的字符串表示&lt;/p&gt;

&lt;p&gt;3、RegExp 实例方法&lt;/p&gt;

&lt;p&gt; *
exec()：专为捕获组设计，接收一个参数，即要应用模式的字符串，返回第一个匹配项信息的数组或者没有匹配项的时候返回
null。返回的数组包含两个额外属性：index 和
input，分别表示匹配项在字符串中的位置和应用正则表达式的字符串。&lt;/p&gt;

&lt;p&gt; * test()：接收一个字符串参数，模式与该参数匹配返回 true，否则返回 false&lt;/p&gt;

&lt;p&gt;二、Function 类型&lt;/p&gt;

&lt;p&gt;1、函数实际上是对象，每个函数都是 Function
类型的实例，具有属性和方法，而函数名实际上是一个指向函数对象的指针，不会与具体的函数绑定。函数通常使用函数声明语法来定义，如：&lt;/p&gt;
function functionName() {}
var functionName = function() {}

&lt;p&gt;2、函数声明与函数表达式的区别：解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
alert(sum1(10, 10));//20
function sum1(num1, num2) {
	return num1 + num2;
}

alert(sum2(10, 10));//error
var sum2 = function(num1, num2) {
	return num1 + num2;
}

&lt;p&gt;3、作为值的函数：不仅可以像传递函数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。也可以从一个函数中返回另一个函数，这是极为有用的技术。&lt;/p&gt;

&lt;p&gt; * 要根据某个对象属性对数组进行排序的例子：&lt;/p&gt;
function createComparisonFunction(propertyName) {
	return function(object1, object2) {
		var value1 = object1[propertyName];
		var value2 = object2[propertyName];
		if (value1 &lt; value2) {
			return -1;
		}

		if (value1 &gt; value2) {
			return 1;
		}

		return 0;
	}
}

var data = [{name: &#34;wenyi&#34;, age: 25}, {name: &#34;l&#34;, age: 26}];
data.sort(createComparisonFunction(&#34;name&#34;));
alert(data[0].name);//&#34;l&#34;

data.sort(createComparisonFunction(&#34;age&#34;));
alert(data[0].name);//&#34;wenyi&#34;

&lt;p&gt;4、函数内部属性&lt;/p&gt;

&lt;p&gt; * arguments：一个类似数组对象，包含着传入函数中的所有参数。还有一个名叫
callee 的属性，该属性是一个指针，指向拥有这个 arguments
对象的函数，主要用于递归函数。如：&lt;/p&gt;
function factorial(num) {
	if (num &lt; 1) {
		return 1;
	}
	return num * arguments.callee(num - 1);
}

&lt;p&gt; * this：引用的是函数据以执行操作的对象，也就是说，this
是函数在执行时所处的作用域。注：函数的名字仅仅是一个包含指针的变量而已。如：&lt;/p&gt;
var name = &#34;window&#34;;
function sayName() {
	alert(this.name);
}

var person = {name: &#34;wenyi&#34;, sayName: sayName};
sayName();//&#34;window&#34;
person.sayName();//&#34;wenyi&#34;

&lt;p&gt;5、函数属性&lt;/p&gt;

&lt;p&gt; * length：表示函数希望接收的命名参数的个数&lt;/p&gt;

&lt;p&gt; * prototype： 保存函数所有实例方法的真是所在。&lt;/p&gt;

&lt;p&gt;6、函数方法：&lt;/p&gt;

&lt;p&gt;（1）apply()和
call()方法，都是在特定的作用于中调用函数，实际上等于设置函数体内 this
对象的值。apply()接收两个参数，第一个是运行函数的作用域，第二个是参数数组。call()除了传入运行函数的作用域之外，必须明确的传入每一个参数。如：&lt;/p&gt;
function sum(num1, num2) {
	return num1 + num2;
}

function applySum(num1, num2) {
	sum.apply(this, arguments);
}

alert(applySum(10, 10));//20
alert(sum.apply(this, [10, 10]));//20
alert(sum.call(this, 10, 10));//20

&lt;p&gt;（2）apply()和
call()方法能够扩充函数赖以运行的作用域，使得对象不需要与方法有任何耦合关系。如：&lt;/p&gt;
var name = &#34;window&#34;;
function sayName() {
	alert(this.name);
}

var person = {name: &#34;wenyi&#34;};
sayName.call(this);//&#34;window&#34;
sayName.call(person);//&#34;wenyi&#34;

&lt;p&gt;三、Global 对象&lt;/p&gt;

&lt;p&gt;1、URI 方法&lt;/p&gt;

&lt;p&gt; * encodeURI()：对 URI 中的空格进行编码，替换成 %20。&lt;/p&gt;

&lt;p&gt; * decodeURI()：对使用 encodeURI 方法进行编码的字符进行解码。&lt;/p&gt;

&lt;p&gt; * encodeURIComponent()：对 URI 中的所有非字母数字字符进行编码。&lt;/p&gt;

&lt;p&gt; * decodeURIComponent()：对使用 encodeURIComponent
方法进行编码的字符进行解码。&lt;/p&gt;

&lt;p&gt;2、eval()方法：完整的 JavaScript
解析器，接收一个参数，将传入的参数当作实际的 JavaScript
语句来解析，并把执行结果插入到原位置。能够解析代码字符串的能力非常强大，同时也非常危险。在使用
eval()时必须十分谨慎，防止恶意输入威胁安全的代码（代码注入）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——数据类型</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_data_types</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_data_types</guid>
      <description>&lt;p&gt;1、JavaScript 中有 5
种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number 和
String；1 种复杂数据类型：Object，Object 本质上由一组无序的名值对组成。&lt;/p&gt;

&lt;p&gt;2、typeof 操作符：用于检测给定变量的数据类型。使用 typeof
操作符可能返回的字符串：&lt;/p&gt;

&lt;p&gt;（1）undefined——该值为未定义（Undefined）或者未声明的变量&lt;/p&gt;

&lt;p&gt;（2）boolean——该值为布尔值（Boolean）&lt;/p&gt;

&lt;p&gt;（3）number——该值为数值（Number）&lt;/p&gt;

&lt;p&gt;（4）string——该值为字符串（String）&lt;/p&gt;

&lt;p&gt;（5）object——该值为对象（Object）或者 Null&lt;/p&gt;

&lt;p&gt;（6）function——该值为函数（Function）&lt;/p&gt;

&lt;p&gt;3、Undefined 类型：只有一个值，即特殊的 undefined。在使用 var
声明变量但未对其加以初始化时，这个变量的值就是
undefined。由于对未初始化和未声明的变量使用 typeof 操作符都返回
undefined，建议养成显式初始化变量（在声明变量的同事给变量赋值）的习惯。&lt;/p&gt;

&lt;p&gt;4、Null 类型：只有一个值，即特殊的 null，表示一个空对象指针。null 和
undefined 有特殊的关系：null == undefined
//true，但它们的用途完全不同，对于
undefined，无论在什么情况下都没必要声明一个变量的值为
undefined，而可以声明一个变量为 null 来表示空指针对象。&lt;/p&gt;

&lt;p&gt;5、Boolean 类型：只有两个值 true 和 false&lt;/p&gt;

&lt;p&gt;6、Number
类型：表示整数和浮点数值。整数主要包括十进制整数、八进制整数和十六进制整数。其中，八进制整数第一位必须是
0，然后为八进制数字序列（0~7）。十六进制前两位必须为
0x，然后为十六进制数字（0~9 及 A~F）。&lt;/p&gt;

&lt;p&gt;（1）e 表示法：等于 e 前面的数值乘以 10 的指数次幂&lt;/p&gt;

&lt;p&gt;（2）Number 的最大值为 Number.MAX_VALUE，最小值为
Number.MIN_VALUE，超过最大值或者最小值会被自动转换为 Infinity 或者
-Infinity，可以使用 isFinite() 函数来判断。&lt;/p&gt;

&lt;p&gt;（3）NaN（非数值 Not a
number）：是一个特殊的数字表示一个错误值，如任何数值除以 0 都会返回
NaN，可以使用 isNaN() 函数判断是否为 NaN。&lt;/p&gt;

&lt;p&gt;（4）NaN的两个非同寻常的特点：任何涉及 NaN 的操作都会返回 NaN；NaN
与任何值都不相等，包括 NaN 本身。&lt;/p&gt;

&lt;p&gt;（5）Number 类型用到的转换函数：parseInt() 和
parseFloat()，用于将字符串转换为整数和浮点数。&lt;/p&gt;

&lt;p&gt;7、String 类型：表示由零或者多个 Unicode 字符组成的字符序列，即字符串。&lt;/p&gt;

&lt;p&gt;（1）字符串的特点：JavaScript
中的字符串是不可变的，即字符串一旦创建，值便不能改变。当改变某个字符串变量的时候，首先先销毁原来的字符串，在用一个包含新值的字符串填充该变量。&lt;/p&gt;

&lt;p&gt;（2）数值、布尔值、对象和字符串都有 toString() 方法，转换为字符串类型。&lt;/p&gt;

&lt;p&gt;8、Object 类型：表示一组数据和功能的集合。可以通过 new
操作符来创建对象：var o = new Object()。而创建 Object
类型的实力并为其添加属性和方法，就可以创建自定义对象。Object
的每个实例都具有的属性和方法：&lt;/p&gt;

&lt;p&gt;（1）constructor——保存着用于创建当前对象的函数，即构造函数。&lt;/p&gt;

&lt;p&gt;（2）hasOwnProperty(propertyName)——用于检查指定的属性在当前对象实例中是否存在。&lt;/p&gt;

&lt;p&gt;（3）isPrototypeof(object)——用于检查传入的对象是否是另一个对象的原型。&lt;/p&gt;

&lt;p&gt;（4）propertyIsEnumerabled(propertyName)——用于检查给定的属性是否能够使用
for-in 语句来枚举。&lt;/p&gt;

&lt;p&gt;（5）toString()——返回对象的字符串表示。&lt;/p&gt;

&lt;p&gt;（6）valueOf()——返回对象的字符串、数值或布尔值表示。&lt;/p&gt;

&lt;p&gt;9、其他应该注意的问题：&lt;/p&gt;

&lt;p&gt;（1）switch
语句在比较值时使用的是全等操作符，因此不会发生类型转换，如字符串不会自动转换为整数。&lt;/p&gt;

&lt;p&gt;（2）function 函数的参数可以用 argument
对象来获取，而函数命名的参数只是提供便利，而不是必须的。JavaScript
中的所有参数传递的都是值，不可能通过引用传递参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——数据类型</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_data_types</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_data_types</guid>
      <description>&lt;p&gt;1、JavaScript 中有 5
种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number 和
String；1 种复杂数据类型：Object，Object 本质上由一组无序的名值对组成。&lt;/p&gt;

&lt;p&gt;2、typeof 操作符：用于检测给定变量的数据类型。使用 typeof
操作符可能返回的字符串：&lt;/p&gt;

&lt;p&gt;（1）undefined——该值为未定义（Undefined）或者未声明的变量&lt;/p&gt;

&lt;p&gt;（2）boolean——该值为布尔值（Boolean）&lt;/p&gt;

&lt;p&gt;（3）number——该值为数值（Number）&lt;/p&gt;

&lt;p&gt;（4）string——该值为字符串（String）&lt;/p&gt;

&lt;p&gt;（5）object——该值为对象（Object）或者 Null&lt;/p&gt;

&lt;p&gt;（6）function——该值为函数（Function）&lt;/p&gt;

&lt;p&gt;3、Undefined 类型：只有一个值，即特殊的 undefined。在使用 var
声明变量但未对其加以初始化时，这个变量的值就是
undefined。由于对未初始化和未声明的变量使用 typeof 操作符都返回
undefined，建议养成显式初始化变量（在声明变量的同事给变量赋值）的习惯。&lt;/p&gt;

&lt;p&gt;4、Null 类型：只有一个值，即特殊的 null，表示一个空对象指针。null 和
undefined 有特殊的关系：null == undefined
//true，但它们的用途完全不同，对于
undefined，无论在什么情况下都没必要声明一个变量的值为
undefined，而可以声明一个变量为 null 来表示空指针对象。&lt;/p&gt;

&lt;p&gt;5、Boolean 类型：只有两个值 true 和 false&lt;/p&gt;

&lt;p&gt;6、Number
类型：表示整数和浮点数值。整数主要包括十进制整数、八进制整数和十六进制整数。其中，八进制整数第一位必须是
0，然后为八进制数字序列（0~7）。十六进制前两位必须为
0x，然后为十六进制数字（0~9 及 A~F）。&lt;/p&gt;

&lt;p&gt;（1）e 表示法：等于 e 前面的数值乘以 10 的指数次幂&lt;/p&gt;

&lt;p&gt;（2）Number 的最大值为 Number.MAX_VALUE，最小值为
Number.MIN_VALUE，超过最大值或者最小值会被自动转换为 Infinity 或者
-Infinity，可以使用 isFinite() 函数来判断。&lt;/p&gt;

&lt;p&gt;（3）NaN（非数值 Not a
number）：是一个特殊的数字表示一个错误值，如任何数值除以 0 都会返回
NaN，可以使用 isNaN() 函数判断是否为 NaN。&lt;/p&gt;

&lt;p&gt;（4）NaN的两个非同寻常的特点：任何涉及 NaN 的操作都会返回 NaN；NaN
与任何值都不相等，包括 NaN 本身。&lt;/p&gt;

&lt;p&gt;（5）Number 类型用到的转换函数：parseInt() 和
parseFloat()，用于将字符串转换为整数和浮点数。&lt;/p&gt;

&lt;p&gt;7、String 类型：表示由零或者多个 Unicode 字符组成的字符序列，即字符串。&lt;/p&gt;

&lt;p&gt;（1）字符串的特点：JavaScript
中的字符串是不可变的，即字符串一旦创建，值便不能改变。当改变某个字符串变量的时候，首先先销毁原来的字符串，在用一个包含新值的字符串填充该变量。&lt;/p&gt;

&lt;p&gt;（2）数值、布尔值、对象和字符串都有 toString() 方法，转换为字符串类型。&lt;/p&gt;

&lt;p&gt;8、Object 类型：表示一组数据和功能的集合。可以通过 new
操作符来创建对象：var o = new Object()。而创建 Object
类型的实力并为其添加属性和方法，就可以创建自定义对象。Object
的每个实例都具有的属性和方法：&lt;/p&gt;

&lt;p&gt;（1）constructor——保存着用于创建当前对象的函数，即构造函数。&lt;/p&gt;

&lt;p&gt;（2）hasOwnProperty(propertyName)——用于检查指定的属性在当前对象实例中是否存在。&lt;/p&gt;

&lt;p&gt;（3）isPrototypeof(object)——用于检查传入的对象是否是另一个对象的原型。&lt;/p&gt;

&lt;p&gt;（4）propertyIsEnumerabled(propertyName)——用于检查给定的属性是否能够使用
for-in 语句来枚举。&lt;/p&gt;

&lt;p&gt;（5）toString()——返回对象的字符串表示。&lt;/p&gt;

&lt;p&gt;（6）valueOf()——返回对象的字符串、数值或布尔值表示。&lt;/p&gt;

&lt;p&gt;9、其他应该注意的问题：&lt;/p&gt;

&lt;p&gt;（1）switch
语句在比较值时使用的是全等操作符，因此不会发生类型转换，如字符串不会自动转换为整数。&lt;/p&gt;

&lt;p&gt;（2）function 函数的参数可以用 argument
对象来获取，而函数命名的参数只是提供便利，而不是必须的。JavaScript
中的所有参数传递的都是值，不可能通过引用传递参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——继承</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_inheritance</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_inheritance</guid>
      <description>&lt;p&gt;1、JavaScript
中实现继承主要是依靠原型链来实现的。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;/p&gt;

&lt;p&gt;2、实现继承模式&lt;/p&gt;

&lt;p&gt;（1）基本模式&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function SuperType() {
	this.property = true;
}

SuperType.prototype.getSuperType = function() {
	return this.property;
};

function SubType() {
	this.subproperty = false;
}

SubType.prototype = new SuperType();

SubType.prototype.getSubValue() {
	return this.subproperty;
};

&lt;p&gt;//重写&lt;/p&gt;
SubType.prototype.getSuperValue() {
	return this.subproperty; 
}

var subType = new SubType();
alert(subType.getSuperType());//false
alert(subType.getSubType());//false

&lt;p&gt; * 默认原型：所有引用类型默认都继承了
Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是 Object
的实例，默认原型都会包含一个内部指针，指向 Object.prototype&lt;/p&gt;

&lt;p&gt; * 重写超类型中的方法：重新定义原型链中的方法&lt;/p&gt;

&lt;p&gt; * 注意：通过原型链实现继承时，不能使用字面量创建原型方法。&lt;/p&gt;

&lt;p&gt; *
存在的问题：包含引用类型的原型属性会被所有实例共享；在创建子类的实例时，不能向超类型传递参数。&lt;/p&gt;

&lt;p&gt;（2）借用构造函数（constructor
stealing）模式：在子类型构造函数的内部调用超类型构造函数。一般是通过使用
apply() 和 call() 方法来是调用。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function SuperType(name) {
	this.name = name;
	this.sayName = function() {
		alert(this.name);
	};
}

function SubType(name, age) {
	SuperType.call(this, name);
	this.age = age;
	this.sayAge = function() {
		alert(this.age);
	}
}

var subType = new SubType(&#34;wenyi&#34;, 25);
subType.sayName();//&#34;wenyi&#34;
subType.sayAge();//25

&lt;p&gt; *
存在的问题：跟构造函数存在同样的问题，即方法都在构造函数中定义，函数无法复用。&lt;/p&gt;

&lt;p&gt;（3）组合继承（combination
inheritance）模式：也叫伪经典继承，指的是将原型链和构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。使用原型琏实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function SuperType(name) {
	this.name = name;
}

SuperType.prototype.sayName = function() {
	alert(this.name);
};

function SubType(name, age) {
	SuperType.call(this, name);
	this.age = age;
}

SubType.prototype = new SuperType();
SubType.prototype.sayAge = function() {
	alert(this.age);
};

var subType = new SubType(&#34;wenyi&#34;, 25);
subType.sayName();//&#34;wenyi&#34;
subType.sayAge();//25

&lt;p&gt; * 存在的问题：无论在什么情况下，都会调用两次超类型构造函数。&lt;/p&gt;

&lt;p&gt;（4）寄生式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回对象。这种模式主要用于对象而不是自定义类型和构造函数的情况下。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function createAnother(original) {
	function clone(o) {
		function F(){};
		F.prototype = o;
		return new F();
	}
	
	var another = clone(original);
	another.sayHi = function() {//以某种方式来增强对象
		alert(&#34;hi&#34;);
	}

	return another;//返回对象
}

var person = {
	name: &#34;wenyi&#34;,
	age: 25
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi();//&#34;hi&#34;

&lt;p&gt;（5）寄生组合式继承：通过借用构造函数来继承属性，通过原型链来继承方法，不调用超类型的构造函数，而是通过寄生式继承得到超类型的一个副本。这种模式组合了以上三种继承方式，是继承引用类型最理想的继承范式。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function inheritPrototype(subType, superType) {
	function clone(o) {
		function F(){};
		F.prototype = o;
		return new F();
	}
	
	var prototype = clone(subperType.prototype);
	prototype.constructor = subType;
	subType.prototype = prototype;
}

function SuperType(name) {
	this.name = name;
}

SuperType.prototype.sayName = function() {
	alert(this.name);
};

function SubType(name, age) {
	SuperType.call(this, name);
	this.age = age;
}

inheritPrototype(SubType, SuperType);
	SubType.prototype.sayAge = function() {
	alert(this.age);
};

var subType = new SubType(&#34;wenyi&#34;, 25);
subType.sayName();//&#34;wenyi&#34;
subType.sayAge();//25

&lt;p&gt; * 注：jQuery 中的 $.extend() 方法和 YUI 的 YAHOO.lang.extend()
方法都使用了继承组合继承。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——继承</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_inheritance</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_inheritance</guid>
      <description>&lt;p&gt;1、JavaScript
中实现继承主要是依靠原型链来实现的。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;/p&gt;

&lt;p&gt;2、实现继承模式&lt;/p&gt;

&lt;p&gt;（1）基本模式&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function SuperType() {
	this.property = true;
}

SuperType.prototype.getSuperType = function() {
	return this.property;
};

function SubType() {
	this.subproperty = false;
}

SubType.prototype = new SuperType();

SubType.prototype.getSubValue() {
	return this.subproperty;
};

&lt;p&gt;//重写&lt;/p&gt;
SubType.prototype.getSuperValue() {
	return this.subproperty; 
}

var subType = new SubType();
alert(subType.getSuperType());//false
alert(subType.getSubType());//false

&lt;p&gt; * 默认原型：所有引用类型默认都继承了
Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是 Object
的实例，默认原型都会包含一个内部指针，指向 Object.prototype&lt;/p&gt;

&lt;p&gt; * 重写超类型中的方法：重新定义原型链中的方法&lt;/p&gt;

&lt;p&gt; * 注意：通过原型链实现继承时，不能使用字面量创建原型方法。&lt;/p&gt;

&lt;p&gt; *
存在的问题：包含引用类型的原型属性会被所有实例共享；在创建子类的实例时，不能向超类型传递参数。&lt;/p&gt;

&lt;p&gt;（2）借用构造函数（constructor
stealing）模式：在子类型构造函数的内部调用超类型构造函数。一般是通过使用
apply() 和 call() 方法来是调用。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function SuperType(name) {
	this.name = name;
	this.sayName = function() {
		alert(this.name);
	};
}

function SubType(name, age) {
	SuperType.call(this, name);
	this.age = age;
	this.sayAge = function() {
		alert(this.age);
	}
}

var subType = new SubType(&#34;wenyi&#34;, 25);
subType.sayName();//&#34;wenyi&#34;
subType.sayAge();//25

&lt;p&gt; *
存在的问题：跟构造函数存在同样的问题，即方法都在构造函数中定义，函数无法复用。&lt;/p&gt;

&lt;p&gt;（3）组合继承（combination
inheritance）模式：也叫伪经典继承，指的是将原型链和构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。使用原型琏实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function SuperType(name) {
	this.name = name;
}

SuperType.prototype.sayName = function() {
	alert(this.name);
};

function SubType(name, age) {
	SuperType.call(this, name);
	this.age = age;
}

SubType.prototype = new SuperType();
SubType.prototype.sayAge = function() {
	alert(this.age);
};

var subType = new SubType(&#34;wenyi&#34;, 25);
subType.sayName();//&#34;wenyi&#34;
subType.sayAge();//25

&lt;p&gt; * 存在的问题：无论在什么情况下，都会调用两次超类型构造函数。&lt;/p&gt;

&lt;p&gt;（4）寄生式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回对象。这种模式主要用于对象而不是自定义类型和构造函数的情况下。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function createAnother(original) {
	function clone(o) {
		function F(){};
		F.prototype = o;
		return new F();
	}
	
	var another = clone(original);
	another.sayHi = function() {//以某种方式来增强对象
		alert(&#34;hi&#34;);
	}

	return another;//返回对象
}

var person = {
	name: &#34;wenyi&#34;,
	age: 25
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi();//&#34;hi&#34;

&lt;p&gt;（5）寄生组合式继承：通过借用构造函数来继承属性，通过原型链来继承方法，不调用超类型的构造函数，而是通过寄生式继承得到超类型的一个副本。这种模式组合了以上三种继承方式，是继承引用类型最理想的继承范式。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function inheritPrototype(subType, superType) {
	function clone(o) {
		function F(){};
		F.prototype = o;
		return new F();
	}
	
	var prototype = clone(subperType.prototype);
	prototype.constructor = subType;
	subType.prototype = prototype;
}

function SuperType(name) {
	this.name = name;
}

SuperType.prototype.sayName = function() {
	alert(this.name);
};

function SubType(name, age) {
	SuperType.call(this, name);
	this.age = age;
}

inheritPrototype(SubType, SuperType);
	SubType.prototype.sayAge = function() {
	alert(this.age);
};

var subType = new SubType(&#34;wenyi&#34;, 25);
subType.sayName();//&#34;wenyi&#34;
subType.sayAge();//25

&lt;p&gt; * 注：jQuery 中的 $.extend() 方法和 YUI 的 YAHOO.lang.extend()
方法都使用了继承组合继承。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——面向对象</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_object_oriented</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_object_oriented</guid>
      <description>&lt;p&gt;1、JavaScript
把的对象定义成散列表：无序属性的集合，其属性可以包含基本值、对象或者函数。&lt;/p&gt;

&lt;p&gt;2、创建对象模式&lt;/p&gt;

&lt;p&gt;（1）最简单的方式：创建一个 Object 的实例，并为它添加属性和方法。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
var person = new Object();
person.name = &#34;wenyi&#34;;
person.age = 25;
person.sayName = function() {
	alert(this.name);
};
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 存在的问题：使用同一个借口创建很多对象，会产生大量的重复代码。&lt;/p&gt;

&lt;p&gt;（2）工厂模式：抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function createPerson(name, age) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}

var person = createPerson(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 存在的问题：没有解决对象识别的问题。&lt;/p&gt;

&lt;p&gt;（3）构造函数模式：用来创建特定类型的对象，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person(name, age) {
	this.name = name;
	this.age = age;

	this.sayName = function() {
		alert(this.name);
	}
}

var person = new Person(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 特点：不用显式的创建对象，而是直接将属性和方法赋给了 this 对象，不用
return&lt;/p&gt;

&lt;p&gt; * 使用：创建构造函数模式对象的实例，需要使用 new 操作符。&lt;/p&gt;

&lt;p&gt; * 构造函数与普通函数的区别：任何函数，只要通过 new
操作符来调用，那它就是构造函数；没有通过 new 操作符来调用，都是普通函数。&lt;/p&gt;

&lt;p&gt; *
存在的问题：每个方法都要在每个实例上重新创建一遍，即每个实例都包含不同的
Function 实例。&lt;/p&gt;

&lt;p&gt;（4）原型模式：创建的每个函数都有一个
prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所以实例共享的属性和方法。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person() {

}

Person.prototype.name = &#34;wenyi&#34;;
Person.prototype.age = 25;
Person.prototype.sayName = function() {
	alert(this.name);
};

var person = new Person();
person.sayName();//&#34;wenyi&#34;
person.name = &#34;test&#34;;
person.sayName();//&#34;test&#34;;

delete person.name;
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 理解原型对象：默认情况下，所有原型对象都会自动获得一个 constructor
属性，这个属性包含一个指向 prototype
属性所在函数的指针。创建自定义的构造函数后，其原型对象默认只会取得
constructor
属性。当调用构造函数创建一个实例后，该实例的内部包含一个内部指针，指向构造函数的原型对象。在实例中，Person.prototype
指向了原型对象，而 Person.prototype.constructor 又指回了 Person&lt;/p&gt;

&lt;p&gt; *
特点：当为原型模型对象实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性；使用
delete 操作符可以删除实例属性，从而重新访问原型属性。&lt;/p&gt;

&lt;p&gt; *
更简单的原型模式语法：使用一个包含所有属性和方法的对象字面量重写整个原型对象，并设置
constructor 的指向。如：&lt;/p&gt;
Person.prototype = {
	constructor: Person,
	
	name: &#34;wenyi&#34;,
	
	age: 25,
	
	sayName: function() {
		alert(this.name);
	}
};

&lt;p&gt; *
存在的问题：原型模式省略了构造函数传递初始化参数，所以的实例都会获得相同的属性值。&lt;/p&gt;

&lt;p&gt;（5）组合使用构造函数模式和原型模式：使用构造模式来定义实例属性，使用原型模式来地定义方法和共享的属性。从而使得每个实例都有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度的节省了内存。这种混成模式是创建自定义类型的最常见方法，是使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person(name, age) {
	this.name = name;
	this.age = age;
}

Person.prototype = {
	constructor: Person,

	sayName: function() {
		alert(this.name);
	}
};

var person = new Person(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;

&lt;p&gt;（6）寄生构造函数模式：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，这个函数是典型的构造函数。这种模式主要用于在特殊的情况下为对象创建构造函数。这种模式返回的对象与构造函数或者与构造函数的原型属性之间没有关系。&lt;/p&gt;

&lt;p&gt; * 创建一个具有额外方法的特殊数组，例子：&lt;/p&gt;
function SpecialArray() {
	var values = new Array();

	values.push.apply(values, arguments);

	values.toPipedString = function() {
		return this.join(&#34;|&#34;);
	}
}

var colors = new SpecicalArray(&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;);
alert(colors.toPipedString());//&#34;red|blue|green&#34;

&lt;p&gt;（7）稳妥构造函数模式：指没有公共的属性，其方法也不引用 this
对象。这种模式主要用于一些安全的环境中，或者防止数据被其他应用程序改动时使用。这种模式返回的对象与构造函数或者与构造函数的原型属性之间没有关系。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person(name, age) {
    var o = new Object();
    
    o.sayName = function() {
        alert(name);
    };

    return o;
}

var person = new Person(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;
</description>
    </item>
    
    <item>
      <title>JavaScript 高级程序设计——面向对象</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_object_oriented</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_advanced_programming_object_oriented</guid>
      <description>&lt;p&gt;1、JavaScript
把的对象定义成散列表：无序属性的集合，其属性可以包含基本值、对象或者函数。&lt;/p&gt;

&lt;p&gt;2、创建对象模式&lt;/p&gt;

&lt;p&gt;（1）最简单的方式：创建一个 Object 的实例，并为它添加属性和方法。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
var person = new Object();
person.name = &#34;wenyi&#34;;
person.age = 25;
person.sayName = function() {
	alert(this.name);
};
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 存在的问题：使用同一个借口创建很多对象，会产生大量的重复代码。&lt;/p&gt;

&lt;p&gt;（2）工厂模式：抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function createPerson(name, age) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}

var person = createPerson(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 存在的问题：没有解决对象识别的问题。&lt;/p&gt;

&lt;p&gt;（3）构造函数模式：用来创建特定类型的对象，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person(name, age) {
	this.name = name;
	this.age = age;

	this.sayName = function() {
		alert(this.name);
	}
}

var person = new Person(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 特点：不用显式的创建对象，而是直接将属性和方法赋给了 this 对象，不用
return&lt;/p&gt;

&lt;p&gt; * 使用：创建构造函数模式对象的实例，需要使用 new 操作符。&lt;/p&gt;

&lt;p&gt; * 构造函数与普通函数的区别：任何函数，只要通过 new
操作符来调用，那它就是构造函数；没有通过 new 操作符来调用，都是普通函数。&lt;/p&gt;

&lt;p&gt; *
存在的问题：每个方法都要在每个实例上重新创建一遍，即每个实例都包含不同的
Function 实例。&lt;/p&gt;

&lt;p&gt;（4）原型模式：创建的每个函数都有一个
prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所以实例共享的属性和方法。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person() {

}

Person.prototype.name = &#34;wenyi&#34;;
Person.prototype.age = 25;
Person.prototype.sayName = function() {
	alert(this.name);
};

var person = new Person();
person.sayName();//&#34;wenyi&#34;
person.name = &#34;test&#34;;
person.sayName();//&#34;test&#34;;

delete person.name;
person.sayName();//&#34;wenyi&#34;

&lt;p&gt; * 理解原型对象：默认情况下，所有原型对象都会自动获得一个 constructor
属性，这个属性包含一个指向 prototype
属性所在函数的指针。创建自定义的构造函数后，其原型对象默认只会取得
constructor
属性。当调用构造函数创建一个实例后，该实例的内部包含一个内部指针，指向构造函数的原型对象。在实例中，Person.prototype
指向了原型对象，而 Person.prototype.constructor 又指回了 Person&lt;/p&gt;

&lt;p&gt; *
特点：当为原型模型对象实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性；使用
delete 操作符可以删除实例属性，从而重新访问原型属性。&lt;/p&gt;

&lt;p&gt; *
更简单的原型模式语法：使用一个包含所有属性和方法的对象字面量重写整个原型对象，并设置
constructor 的指向。如：&lt;/p&gt;
Person.prototype = {
	constructor: Person,
	
	name: &#34;wenyi&#34;,
	
	age: 25,
	
	sayName: function() {
		alert(this.name);
	}
};

&lt;p&gt; *
存在的问题：原型模式省略了构造函数传递初始化参数，所以的实例都会获得相同的属性值。&lt;/p&gt;

&lt;p&gt;（5）组合使用构造函数模式和原型模式：使用构造模式来定义实例属性，使用原型模式来地定义方法和共享的属性。从而使得每个实例都有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度的节省了内存。这种混成模式是创建自定义类型的最常见方法，是使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person(name, age) {
	this.name = name;
	this.age = age;
}

Person.prototype = {
	constructor: Person,

	sayName: function() {
		alert(this.name);
	}
};

var person = new Person(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;

&lt;p&gt;（6）寄生构造函数模式：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，这个函数是典型的构造函数。这种模式主要用于在特殊的情况下为对象创建构造函数。这种模式返回的对象与构造函数或者与构造函数的原型属性之间没有关系。&lt;/p&gt;

&lt;p&gt; * 创建一个具有额外方法的特殊数组，例子：&lt;/p&gt;
function SpecialArray() {
	var values = new Array();

	values.push.apply(values, arguments);

	values.toPipedString = function() {
		return this.join(&#34;|&#34;);
	}
}

var colors = new SpecicalArray(&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;);
alert(colors.toPipedString());//&#34;red|blue|green&#34;

&lt;p&gt;（7）稳妥构造函数模式：指没有公共的属性，其方法也不引用 this
对象。这种模式主要用于一些安全的环境中，或者防止数据被其他应用程序改动时使用。这种模式返回的对象与构造函数或者与构造函数的原型属性之间没有关系。&lt;/p&gt;

&lt;p&gt; * 例子：&lt;/p&gt;
function Person(name, age) {
    var o = new Object();
    
    o.sayName = function() {
        alert(name);
    };

    return o;
}

var person = new Person(&#34;wenyi&#34;, 25);
person.sayName();//&#34;wenyi&#34;
</description>
    </item>
    
    <item>
      <title>JavaScript高级程序设计——在 HTML 中使用 JavaScript</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_programming_using_javascript_in_html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_programming_using_javascript_in_html</guid>
      <description>&lt;p&gt;1、在 HTML 页面中使用 JavaScript的主要方法：使用 script 元素&lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; scr=&#34;src.js&#34; charset=&#34;charset&#34; defer=&#34;defer&#34;&gt;&lt;/script&gt;

&lt;p&gt; • type：用于表示编写代码使用的脚本语言，一般都是 text/javascript&lt;/p&gt;

&lt;p&gt; • src：表示包含执行代码的外部文件，可选&lt;/p&gt;

&lt;p&gt; • charset：表示通过 src 属性制定的代码的字符集，可选&lt;/p&gt;

&lt;p&gt; • defer：表示脚本可以延迟到文档完全被解析和显示之后再执行，可选&lt;/p&gt;

&lt;p&gt;2、标签的位置&lt;/p&gt;

&lt;p&gt;（1）将所有的 script 元素都放在页面的 head 元素中:&lt;/p&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src1.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src2.js&#34;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 这里放内容 --&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;(2)将所有的 script 元素都放到 body 元素中，放在页面的内容后面，推荐使用这种方式：&lt;/p&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 这里放内容 --&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src1.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src2.js&#34;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;3、尽可能使用外部文件来包含 JavaScript 代码：&lt;/p&gt;

&lt;p&gt;（1）可维护性&lt;/p&gt;

&lt;p&gt;（2）可缓存&lt;/p&gt;

&lt;p&gt;（3）可使用未来&lt;/p&gt;

&lt;p&gt;4、文档模式：需要在文档开始加入表示的文档模式&lt;/p&gt;

&lt;p&gt;（1）标准模式：&lt;/p&gt;
&lt;!-- HTML 4.01 严格型 --&gt;
&lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/strict.dtd&#34;&gt;

&lt;p&gt;（2）准标准模式，一般使用过渡型模式：&lt;/p&gt;
&lt;!-- HTML 4.01 过渡型 --&gt;
&lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/loose.dtd&#34;&gt;
&lt;!-- HTML 4.01 框架集型 --&gt;
&lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/frameset.dtd&#34;&gt;

&lt;p&gt;5、noscript 元素&lt;/p&gt;

&lt;p&gt; • noscript 元素主要用于当浏览器不支持脚本或者脚本被禁用时，浏览器会显示 noscript 中的内容&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript高级程序设计——在 HTML 中使用 JavaScript</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/javascript_programming_using_javascript_in_html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/javascript_programming_using_javascript_in_html</guid>
      <description>&lt;p&gt;1、在 HTML 页面中使用 JavaScript的主要方法：使用 script 元素&lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; scr=&#34;src.js&#34; charset=&#34;charset&#34; defer=&#34;defer&#34;&gt;&lt;/script&gt;

&lt;p&gt; • type：用于表示编写代码使用的脚本语言，一般都是 text/javascript&lt;/p&gt;

&lt;p&gt; • src：表示包含执行代码的外部文件，可选&lt;/p&gt;

&lt;p&gt; • charset：表示通过 src 属性制定的代码的字符集，可选&lt;/p&gt;

&lt;p&gt; • defer：表示脚本可以延迟到文档完全被解析和显示之后再执行，可选&lt;/p&gt;

&lt;p&gt;2、标签的位置&lt;/p&gt;

&lt;p&gt;（1）将所有的 script 元素都放在页面的 head 元素中:&lt;/p&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src1.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src2.js&#34;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 这里放内容 --&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;(2)将所有的 script 元素都放到 body 元素中，放在页面的内容后面，推荐使用这种方式：&lt;/p&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 这里放内容 --&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src1.js&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;src2.js&#34;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;3、尽可能使用外部文件来包含 JavaScript 代码：&lt;/p&gt;

&lt;p&gt;（1）可维护性&lt;/p&gt;

&lt;p&gt;（2）可缓存&lt;/p&gt;

&lt;p&gt;（3）可使用未来&lt;/p&gt;

&lt;p&gt;4、文档模式：需要在文档开始加入表示的文档模式&lt;/p&gt;

&lt;p&gt;（1）标准模式：&lt;/p&gt;
&lt;!-- HTML 4.01 严格型 --&gt;
&lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/strict.dtd&#34;&gt;

&lt;p&gt;（2）准标准模式，一般使用过渡型模式：&lt;/p&gt;
&lt;!-- HTML 4.01 过渡型 --&gt;
&lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/loose.dtd&#34;&gt;
&lt;!-- HTML 4.01 框架集型 --&gt;
&lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/frameset.dtd&#34;&gt;

&lt;p&gt;5、noscript 元素&lt;/p&gt;

&lt;p&gt; • noscript 元素主要用于当浏览器不支持脚本或者脚本被禁用时，浏览器会显示 noscript 中的内容&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web 前端开发有用的代码片段</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/web_code_gist</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/web_code_gist</guid>
      <description>

&lt;h3 id=&#34;1-定时器:517902b7277b9dd563d99f8ec5586bdc&#34;&gt;1. 定时器&lt;/h3&gt;

&lt;p&gt;经常会用到 setTimeout 和 setInterval 函数，假如可以整合起来，会方便很多：&lt;/p&gt;
function timer(func, start, interval, end) {
    start = start || 0;
    if (arguments.length &lt;= 2) {
        setTimeout(func, start);
    } else {
        var repeat = function() {
            var i = setInterval(func, interval);
            end &amp;&amp; setTimeout(function() {
                clearInterval(i);
            }, end);
        };
        setTimeout(repeat, start);
    }
}

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func：需要运行的函数&lt;/li&gt;
&lt;li&gt;start：开始时间，单位为毫秒，不填表示立即开始&lt;/li&gt;
&lt;li&gt;interval：运行间隔，单位为毫秒，不填表示运行一次&lt;/li&gt;
&lt;li&gt;end：结束时间，单位为毫秒&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子：&lt;/p&gt;
// 立即运行
timer(function() {
    console.log(&#39;test1&#39;);
});

// 2秒后开始运行
timer(function() {
    console.log(&#39;test2&#39;);
}, 2000);

// 2秒后开始运行，并隔2秒重复运行1次
timer(function() {
    console.log(&#39;test3&#39;);
}, 2000, 2000);

// 2秒后开始运行，并隔1秒重复运行1次，结束时间为10秒后
timer(function() {
    console.log(&#39;test4&#39;);
}, 2000, 1000, 10000);

&lt;p&gt;源码：&lt;a href=&#34;https://gist.github.com/wenzhixin/5820136&#34;&gt;https://gist.github.com/wenzhixin/5820136&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-url-解析:517902b7277b9dd563d99f8ec5586bdc&#34;&gt;2. url 解析&lt;/h3&gt;

&lt;p&gt;在看 location 的时候（详细见《JavaScript权威指南》14.2 浏览器定位和导航），说到 location 同时也适用与 a 和 area 标签，
于是在想平时不是经常要解析 url 字符串嘛，那利用 a 或者 area 标签岂不是更省事：&lt;/p&gt;
function url(href) {
    var a = document.createElement(&#39;a&#39;);//or document.createElement(&#39;area&#39;)
    a.href = href;
    return a;
}

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;href：需要解析的 href 字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子：&lt;/p&gt;
var u = url(&#39;http://wenzhixin.net.cn:12345/test?name=wenzhixin#about&#39;);
console.log(u.protocol); // http:
console.log(u.hostname); // wenzhixin.net.cn
console.log(u.port); // 12345
console.log(u.pathname); // /test
console.log(u.search); // ?name=wenzhixin
console.log(u.hash); // #about

&lt;p&gt;源码：&lt;a href=&#34;https://gist.github.com/wenzhixin/5820633&#34;&gt;https://gist.github.com/wenzhixin/5820633&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-search-解析:517902b7277b9dd563d99f8ec5586bdc&#34;&gt;3. search 解析&lt;/h3&gt;

&lt;p&gt;解析 location.search，转换为对象：&lt;/p&gt;
function parse(search) {
    var query = {}, 
        params = search.substring(1).split(&#39;&amp;&#39;);
    for (var i = 0, l = params.length; i &lt; l; i++) {
        var p = params[i].split(&#39;=&#39;);
        query[p[0]] = p[1] || &#39;&#39;;
    }
    return query;
}

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;search：query 查询字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子：&lt;/p&gt;
var query = parse(&#39;?name=zhixin&amp;age=26&amp;blog=wenzhixin.net.cn&amp;ttt&#39;);
console.log(query); // Object {name: &#34;zhixin&#34;, age: &#34;26&#34;, blog: &#34;wenzhixin.net.cn&#34;, ttt: &#34;&#34;}

&lt;p&gt;源码：&lt;a href=&#34;https://gist.github.com/wenzhixin/5823839&#34;&gt;https://gist.github.com/wenzhixin/5823839&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;问题：想过用正则&lt;/p&gt;
.*\?(?:(\w+)=(\w+)&amp;)*(\w+)=(\w+)

&lt;p&gt;来实现的，可是没能匹配出来，结果只能匹配出最后两个，
才知道是因为 Groups only remember the last value they captured。 或许，有更好的办法？&lt;/p&gt;

&lt;h3 id=&#34;4:517902b7277b9dd563d99f8ec5586bdc&#34;&gt;4. &amp;hellip;&lt;/h3&gt;

&lt;p&gt;(未完待续&amp;hellip;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>