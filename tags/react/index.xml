<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/tags/react/</link>
    <description>Recent content in React on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <atom:link href="http://blog.wenzhixin.net.cn/tags/react/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>react-memory：基于 nodejs &#43; bower &#43; react 的文字记忆游戏</title>
      <link>http://blog.wenzhixin.net.cn/1/01/01/react_memory</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/1/01/01/react_memory</guid>
      <description>

&lt;h3 id=&#34;前言:126e5f0c3267828479b5a765d781e066&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;现在最热门的前端框架，毫无疑问是 &lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;，React 是由 Facebook 出品的 JavaScript 框架，由于该框架比较新，比较少中文的资料。这几天看了很多篇关于 react 的英文文章，不得不说 React 是创建大型、快速的 Web 应用的最好方式。在本文中，我们将通过一步一步的创建一个简单的文字记忆游戏，来体验 React 的思想和强大之处。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 由于对 React 的学习也是皮毛，但是在这里，我希望这个小游戏能够成为学习 React 的最佳开发结构，并且随着自己的不断学习，将会继续改进和完善这里的代码。假如您有任何的建议和反馈，请给我留言，谢谢！&lt;/p&gt;

&lt;p&gt;在开始之前我们先来看看我们的 &lt;a href=&#34;http://demos.wenzhixin.net.cn/react-memory&#34;&gt;demo&lt;/a&gt;，游戏非常简单，输入想要记忆的文字，然后点击开始记忆即可。试玩了我们的游戏之后，那么现在就开始吧。&lt;/p&gt;

&lt;p&gt;先来看看我们的目录结构，你可以在 GitHub 上找到相对应的&lt;a href=&#34;https://github.com/wenzhixin/react-memory&#34;&gt;源码&lt;/a&gt;：&lt;/p&gt;
├── bower_components
│   ├── bootstrap
│   └── jquery
├── node_modules
│   ├── browserify
│   ├── lodash
│   ├── react
│   ├── reactify
│   └── watchify
├── docs
│   ├── component.dot
│   └── component.png
├── build
│   └── app.js
├── css
│   └── style.css
├── index.html
├── js
│   ├── app.js
│   ├── board.js
│   ├── game.js
│   ├── status.js
│   ├── tile.js
│   └── word-form.js
├── bower.json
├── package.json
└── README.md

&lt;ul&gt;
&lt;li&gt;bower_components 和 bower.json 是安装 bower 组件的目录和配置信息。&lt;/li&gt;
&lt;li&gt;node_modules 和 package.json 是安装 npm 模块的目录和配置信息。&lt;/li&gt;
&lt;li&gt;docs 用于存放我们的文档信息。&lt;/li&gt;
&lt;li&gt;css 和 js 用于存放样式和 JavaScript 源码。&lt;/li&gt;
&lt;li&gt;build 用于存放最后编译的 css 和 js 文件。&lt;/li&gt;
&lt;li&gt;index.html 是我们游戏的主页面，也就是 React 的入口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;初始化:126e5f0c3267828479b5a765d781e066&#34;&gt;初始化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;首先，创建 npm 模块的配置文件 package.json&lt;/li&gt;
&lt;/ul&gt;
{
    &#34;name&#34;: &#34;react-memory&#34;,
    &#34;version&#34;: &#34;1.0.0&#34;,
    &#34;description&#34;: &#34;基于 nodejs + bower + react 的文字记忆游戏。&#34;,
    &#34;browserify&#34;: {
        &#34;transform&#34;: [
            [&#34;reactify&#34;]
        ]
    },
    &#34;author&#34;: &#34;wenzhixin &lt;wenzhixin2010@gmail.com&gt; (http://wenzhixin.net.cn/)&#34;,
    &#34;license&#34;: &#34;MIT&#34;
}

&lt;ul&gt;
&lt;li&gt;接着，创建 bower 组件的配置文件 bower.json&lt;/li&gt;
&lt;/ul&gt;
{
    &#34;name&#34;: &#34;react-memory&#34;,
    &#34;version&#34;: &#34;1.0.0&#34;,
    &#34;authors&#34;: [
        &#34;zhixin &lt;wenzhixin2010@gmail.com&gt;&#34;
    ],
    &#34;license&#34;: &#34;MIT&#34;,
    &#34;ignore&#34;: [
        &#34;**/.*&#34;,
        &#34;node_modules&#34;,
        &#34;bower_components&#34;,
        &#34;test&#34;,
        &#34;tests&#34;
    ]
}

&lt;ul&gt;
&lt;li&gt;安装所需要的依赖包&lt;/li&gt;
&lt;/ul&gt;
# 运行游戏时需要的依赖包
npm install --save react lodash
bower install --save bootstrap

# 编译游戏时需要的依赖包
npm install --save-dev browserify watchify reactify

# 全局命令行工具
npm install -g browserify watchify http-server

&lt;p&gt;可以看到，我们安装了运行游戏时所需要的依赖包：react，&lt;a href=&#34;https://github.com/lodash/lodash/&#34;&gt;lodash&lt;/a&gt; 模块，以及 &lt;a href=&#34;https://github.com/twbs/bootstrap&#34;&gt;bootstrap&lt;/a&gt; 组件，lodash 是一个非常实用的工具库，游戏中我们使用到了好多它所提供的操作 array 的简单方法，react 和 bootstrap 的话就不用说了。&lt;/p&gt;

&lt;h3 id=&#34;react-组件依赖层次:126e5f0c3267828479b5a765d781e066&#34;&gt;React 组件依赖层次&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/wenzhixin/react-memory/raw/master/docs/component.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;React 中都是以组件的方式来体现的，从上往下，我们切割成非常小、功能单一的组件，分别是：
* Game：游戏组件
* WordForm：文字输入组价
* Board：游戏面板组件
* Status：游戏状态组价
* Tile：单个卡片组件&lt;/p&gt;

&lt;h3 id=&#34;组件模板:126e5f0c3267828479b5a765d781e066&#34;&gt;组件模板&lt;/h3&gt;

&lt;p&gt;由于我们使用了 nodejs 的开发方式以及 React 独有的 JSX 语法，我们组件的模板为：&lt;/p&gt;
var React = require(&#39;react&#39;), // 加载 react 模块
    _ = require(&#39;lodash&#39;), // 加载 lodash 模块
    OtherComponent = require(&#39;./other-component&#39;); // 加载其他自定义 React 模块

var Component = React.createClass({
    // 定义组件所需要的 properties 属性
    propTypes: {
        prop1: React.PropTypes.string.isRequired,
        func1: React.PropTypes.func.isRequired
    },
    // 初始化组件的状态，并非所有组件都需要 state
    getInitialState: function () {
        return {};
    },
    // 渲染我们的界面
    render: function () {
        return (
            &lt;OtherComponent prop1={this.props.prop1} func1={{this.props.func1}} /&gt;
        );
    }
});

module.exports = Component;

&lt;p&gt;对于各行代码的意思，已加了详细的注释说明，在下面的 js 代码中，也是一样在代码中做了详细注释，由于我们只关注组件的核心部分，与模板相同的地方，我们就不做解释了。&lt;/p&gt;

&lt;h3 id=&#34;game:126e5f0c3267828479b5a765d781e066&#34;&gt;Game&lt;/h3&gt;

&lt;p&gt;创建文件：&lt;code&gt;js/game.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;),
    _ = require(&#39;lodash&#39;),
    Board = require(&#39;./board&#39;),
    WordForm = require(&#39;./word-form&#39;);

var Game = React.createClass({
    // 初始化 state，这里我们使用了 words 数组，用于保存输入的文字
    getInitialState: function () {
        return {words: undefined};
    },
    // 开始游戏
    startGame: function (words) {
        this.setState({
            // 组合并打乱输入的文字
            words: _.shuffle(words.concat(words))
        });
    },
    // 结束游戏，设置 words 为 undefined
    endGame: function () {
        this.setState({words: undefined});
    },
    // 根据 words 来显示我们自定义的组件
    render: function () {
        return (
            this.state.words ?
                &lt;Board onEndGame={this.endGame} words={this.state.words}/&gt; :
                &lt;WordForm onWordsEntered={this.startGame} /&gt;
        );
    }
});

module.exports = Game;

&lt;h3 id=&#34;wordform:126e5f0c3267828479b5a765d781e066&#34;&gt;WordForm&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新建文件：&lt;code&gt;js/word-form.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
var React = require(&#39;react&#39;),
    _ = require(&#39;lodash&#39;);

var WordForm = React.createClass({
    // 需要提供 onWordsEntered 方法，用于触发提交方法，在 Game 中我们使用了 startGame
    propTypes: {
        onWordsEntered: React.PropTypes.func.isRequired
    },
    // 初始化 error 状态
    getInitialState: function () {
        return {error: undefined};
    },
    // 显示错误信息，2s 后自动消失
    setError: function (msg) {
        this.setState({error: msg});
        setTimeout(function () {
            this.setState({error: &#39;&#39;});
        }.bind(this), 2000);
    },
    // 提交文字信息，判断是否符合条件
    submitWords: function (e) {
        e.preventDefault();

        var node = this.refs.words.getDOMNode(),
            // unique 用于生成唯一的字符
            words = _.unique((node.value || &#39;&#39;).trim().split(&#39;&#39;));

        if (words.length &lt; 3) {
            this.setError(&#39;请至少输入三个不同的字符！&#39;);
        } else {
            this.props.onWordsEntered(words);
            node.value = &#39;&#39;;
        }
    },
    render: function () {
        return (
            &lt;form className=&#39;form-inline&#39; onSubmit={this.submitWords}&gt;
                &lt;span&gt;请输入你想记忆的字符：&lt;/span&gt;
                &lt;input className=&#39;form-control&#39; type=&#39;text&#39; ref=&#39;words&#39; maxLength=&#39;10&#39;
                    defaultValue=&#39;文字记忆游戏&#39; /&gt;
                &lt;button className=&#39;btn btn-default&#39; type=&#39;submit&#39;&gt;开始记忆&lt;/button&gt;
                &lt;p className=&#39;error&#39;&gt;{this.state.error}&lt;/p&gt;
            &lt;/form&gt;
        );
    }
});

module.exports = WordForm;

&lt;ul&gt;
&lt;li&gt;由于用用到了 bootstrap 的样式和自定义了 error 样式，需要创建 &lt;code&gt;css/style.css&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;
@import &#34;../bower_components/bootstrap/dist/css/bootstrap.min.css&#34;;

.error {
    color: red;
}

&lt;h3 id=&#34;boar:126e5f0c3267828479b5a765d781e066&#34;&gt;Boar&lt;/h3&gt;

&lt;p&gt;新建文件：&lt;code&gt;js/board.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;),
    _ = require(&#39;lodash&#39;),
    Tile = require(&#39;./tile&#39;),
    Status = require(&#39;./status&#39;);

var Board = React.createClass({
    // 需要提供 words 属性，以及 onEndGame 方法，分别对应 Game 的属性和方法
    propTypes: {
        words: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
        onEndGame: React.PropTypes.func.isRequired
    },
    // 在组件还未 mount 之前用于计算总共有多少对文字卡片
    componentWillMount: function () {
        this.max = this.props.words.length / 2;
    },
    // State 状态
    // found：表示找到了多少对文字卡片
    // message：显示当前的状态
    // tileStates
    getInitialState: function () {
        return {
            found: 0,
            message: &#39;chooseTile&#39;,
            tileStates: new Array(this.props.words.length + 1).join(&#39;unturned &#39;).trim().split(&#39; &#39;)
        };
    },
    // 游戏逻辑的处理方法
    clickedTile: function (index) {
        // 当卡片的状态为 unturned（未翻转）时，才进行处理
        if (this.state.tileStates[index] === &#39;unturned&#39;) {
            // flippedTile 用于保存上个点击的卡片的 index
            if (this.flippedTile === undefined) {
                this.flippedTile = index;
                // 设置状态为 findMate
                this.setState({
                    message: &#39;findMate&#39;,
                    // 使用 lodash 方法，将对应的下标置为 revealed（翻转）状态
                    tileStates: _.extend(this.state.tileStates, _.object([index], [&#39;revealed&#39;]))
                });
            } else {
                var otherIndex = this.flippedTile,
                    matched = this.props.words[index] === this.props.words[this.flippedTile];

                if (matched) {
                    // 找到相对应的卡片，found + 1，并将状态置为 foundMate
                    this.setState({
                        found: this.state.found + 1,
                        message: &#39;foundMate&#39;,
                        // 使用 lodash 方法，将对应的下标置为 correct（正确）状态
                        tileStates: _.extend(this.state.tileStates,
                            _.object([index, otherIndex], [&#39;correct&#39;, &#39;correct&#39;]))
                    });
                } else {
                    // 没有找到相对应的卡片，将状态置为 wrong
                    this.setState({
                        message: &#39;wrong&#39;,
                        // 使用 lodash 方法，将对应的下标置为 wrong（错误）状态
                        tileStates: _.extend(this.state.tileStates,
                            _.object([index, otherIndex], [&#39;wrong&#39;, &#39;wrong&#39;]))
                    });
                }
                // 删除保存的信息
                delete this.flippedTile;

                // 1.5s 后我们将卡片翻转回来
                setTimeout(function () {
                    // 需要判断组件是否 mounted
                    if (this.isMounted()) {
                        // 假如所有都选中了，将状态置为 foundAll
                        this.setState({
                            message: this.state.message === &#39;findMate&#39; ? &#39;findMate&#39; :
                                this.max === this.state.found ? &#39;foundAll&#39; : &#39;chooseTile&#39;,
                            tileStates: matched ? this.state.tileStates : _.extend(this.state.tileStates,
                                _.object([index, otherIndex], [&#39;unturned&#39;, &#39;unturned&#39;]))
                        });
                    }
                }.bind(this), 1500);
            }
        }
    },
    render: function () {
        // 使用 map 方式，将所有的卡片显示出来
        var tiles = this.props.words.map(function (word, i) {
            return (
                &lt;div key={i} onClick={_.partial(this.clickedTile, i)}&gt;
                    &lt;Tile word={word} status={this.state.tileStates[i]} /&gt;
                &lt;/div&gt;
            );
        }.bind(this));
        return (
            &lt;div&gt;
                &lt;button className=&#39;btn btn-default&#39; onClick={this.props.onEndGame}&gt;结束记忆&lt;/button&gt;
                &lt;Status found={this.state.found} max={this.max} message={this.state.message} /&gt;
                {tiles}
            &lt;/div&gt;
        );
    }
});

module.exports = Board;

&lt;h3 id=&#34;status:126e5f0c3267828479b5a765d781e066&#34;&gt;Status&lt;/h3&gt;

&lt;p&gt;新建文件&lt;code&gt;status.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;);

var Status = React.createClass({
    propTypes: {
        found: React.PropTypes.number.isRequired,
        max: React.PropTypes.number.isRequired,
        message: React.PropTypes.oneOf([
            &#39;chooseTile&#39;, &#39;findMate&#39;, &#39;wrong&#39;, &#39;foundMate&#39;, &#39;foundAll&#39;
        ]).isRequired
    },
    render: function () {
        var found = this.props.found,
            max = this.props.max,
            texts = {
                chooseTile: &#39;选择一张卡片！&#39;,
                findMate: &#39;现在我们来查找相对应的卡片！&#39;,
                wrong: &#39;很遗憾，这两张卡片不匹配！&#39;,
                foundMate: &#39;不错，他们是一对的！&#39;,
                foundAll: &#39;恭喜过关，你已经找到所有&#39; + max + &#39;对卡片了！&#39;
            };
        return (
            &lt;p&gt;({found}/{max})  {texts[this.props.message]}&lt;/p&gt;
        );
    }
});

module.exports = Status;

&lt;h3 id=&#34;tile:126e5f0c3267828479b5a765d781e066&#34;&gt;Tile&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新建文件&lt;code&gt;tile.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
var React = require(&#39;react&#39;);

var Tile = React.createClass({
    propTypes: {
        status: React.PropTypes.string.isRequired,
        word: React.PropTypes.string.isRequired
    },
    render: function () {
        return (
            &lt;div className={&#39;brick &#39; + this.props.status}&gt;
                &lt;div className=&#39;front&#39;&gt;&lt;i className=&#39;glyphicon glyphicon-question-sign&#39;&gt;&lt;/i&gt;&lt;/div&gt;
                &lt;div className=&#39;back&#39;&gt;{this.props.word}&lt;/div&gt;
            &lt;/div&gt;
        );
    }
});

module.exports = Tile;

&lt;ul&gt;
&lt;li&gt;修改文件&lt;code&gt;css/style.css&lt;/code&gt;，增加卡片需要的样式&lt;/li&gt;
&lt;/ul&gt;
@-webkit-keyframes wronganim {
    to {
        background-color: red;
    }
}

@-moz-keyframes wronganim {
    to {
        background-color: red;
    }
}

@keyframes wronganim {
    to {
        background-color: red;
    }
}

@-webkit-keyframes correctanim {
    to {
        background-color: green;
        color: white;
    }
}

@-moz-keyframes correctanim {
    to {
        background-color: green;
        color: white;
    }
}

@keyframes correctanim {
    to {
        background-color: green;
        color: white;
    }
}

.brick &gt; div {
    width: 80px;
    height: 80px;
    border: 1px solid black;
    text-align: center;
    line-height: 80px;
    font-size: 24px;
    -webkit-backface-visibility: hidden;
    -webkit-transition: -webkit-transform 0.3s linear;
    -moz-transition: -moz-transform 0.3s linear;
    transition: transform 0.3s linear;
    -webkit-transform-style: preserve-3d;
    transform-style: preserve-3d;
    position: absolute;
    overflow: hidden;
    border-radius: 5px;
    backface-visibility: hidden;
}

.brick &gt; .front {
    background-color: #AAA;
}

.brick, .brick div {
    user-select: none;
    cursor: pointer;
}

.brick {
    float: left;
    margin-right: 10px;
    margin-bottom: 10px;
    width: 80px;
    height: 80px;
}

.brick &gt; .back {
    -webkit-animation-duration: 0.5s;
    -webkit-animation-timing-function: ease;
    -webkit-animation-delay: 0.3s;
    -webkit-animation-iteration-count: 1;
    -webkit-animation-fill-mode: forwards;
    -moz-animation-duration: 0.5s;
    -moz-animation-timing-function: ease;
    -moz-animation-delay: 0.3s;
    -moz-animation-iteration-count: 1;
    -moz-animation-fill-mode: forwards;
    animation-duration: 0.5s;
    animation-timing-function: ease;
    animation-delay: 0.3s;
    animation-iteration-count: 1;
    animation-fill-mode: forwards;
}

.brick.wrong &gt; .back {
    -webkit-animation-name: wronganim;
    -moz-animation-name: wronganim;
    animation-name: wronganim;
}

.brick.correct &gt; .back {
    -webkit-animation-name: correctanim;
    -moz-animation-name: correctanim;
    animation-name: correctanim;
}

.brick &gt; .back {
    -webkit-transform: perspective(80px) rotateY(180deg) translate3d(0px, 0px, 2px);
    -moz-transform: perspective(80px) rotateY(180deg) translate3d(0px, 0px, 2px);
    transform: perspective(80px) rotateY(180deg) translate3d(0px, 0px, 2px);
}

.brick.correct &gt; .front, .brick.wrong &gt; .front, .brick.revealed &gt; .front {
    -webkit-transform: perspective(80px) rotateY(-180deg) translate3d(0px, 0px, 2px);
    -moz-transform: perspective(80px) rotateY(-180deg) translate3d(0px, 0px, 2px);
    transform: perspective(80px) rotateY(-180deg) translate3d(0px, 0px, 2px);
}

.brick.correct &gt; .back, .brick.wrong &gt; .back, .brick.revealed &gt; .back {
    -webkit-transform: perspective(80px) rotateY(0deg) translate3d(0px, 0px, 1px);
    -moz-transform: perspective(80px) rotateY(0deg) translate3d(0px, 0px, 1px);
    transform: perspective(80px) rotateY(0deg) translate3d(0px, 0px, 1px);
}

.front {
    font-size: 2em;
}

&lt;h3 id=&#34;app-js:126e5f0c3267828479b5a765d781e066&#34;&gt;app.js&lt;/h3&gt;

&lt;p&gt;创建好了我们所有的组件之后，我们需要将组件组合起来，创建文件&lt;code&gt;app.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;),
    Game = require(&#39;./game&#39;);

React.render(
    &lt;Game /&gt;,
    document.getElementById(&#39;app&#39;)
);

&lt;h3 id=&#34;index-html:126e5f0c3267828479b5a765d781e066&#34;&gt;index.html&lt;/h3&gt;

&lt;p&gt;新建文件：&lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&#34;utf-8&#34;&gt;
    &lt;title&gt;记忆游戏&lt;/title&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;css/style.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;nav class=&#34;navbar navbar-inverse navbar-fixed-top&#34;&gt;
    &lt;div class=&#34;container&#34;&gt;
        &lt;div class=&#34;navbar-header&#34;&gt;
            &lt;span class=&#34;navbar-brand&#34;&gt;记忆游戏&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/nav&gt;
&lt;div id=&#34;app&#34; class=&#34;container&#34;&gt;正在努力加载中……&lt;/div&gt;
&lt;script src=&#34;build/app.js&#34;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;h3 id=&#34;查看结果:126e5f0c3267828479b5a765d781e066&#34;&gt;查看结果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;开始编译监听 jsx 文件为 js&lt;/li&gt;
&lt;/ul&gt;
watchify -v -o build/app.js js/app.js

&lt;ul&gt;
&lt;li&gt;启用 http server&lt;/li&gt;
&lt;/ul&gt;
http-server -p 8888

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看界面 &lt;a href=&#34;http://localhost:8888/&#34;&gt;http://localhost:8888/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大功告成，开始开心的游戏吧！&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>