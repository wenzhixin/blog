<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后台技术 on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 后台技术 on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <lastBuildDate>Sun, 21 Sep 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.wenzhixin.net.cn/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何批量读取 word 的内容和图片</title>
      <link>http://blog.wenzhixin.net.cn/2014/09/21/node_docx</link>
      <pubDate>Sun, 21 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/09/21/node_docx</guid>
      <description>

&lt;p&gt;今天朋友说需要对100份 word 文件的内容进行录入工作，问我是否有什么方便的方法。假如最少1份按2分钟的速度算，也需要200分钟才可以录入完成。我一直都不喜欢做重复又无意义的工作，就想着能否用程序来对其进行处理，后面虽然也花了快一个钟的时间来编写代码和测试，但是当程序用了几分钟的时间就将需要的内容全部录入完成时，觉得还是挺开心的，而自己也学到了许多的东西，在这里记录下，我想以后应该也会用到。&lt;/p&gt;

&lt;h3 id=&#34;使用-unoconv-处理-word:7f17c56fe3862cd59715dd8ba3bba088&#34;&gt;使用 unoconv 处理 word&lt;/h3&gt;

&lt;p&gt;首先 word 文件是 &lt;code&gt;.docx&lt;/code&gt;，在 Ubuntu 上，我们可以使用 &lt;code&gt;unoconv&lt;/code&gt; 命令来解析 word 的文件，安装命令如下：&lt;/p&gt;
sudo apt-get install unoconv

&lt;p&gt;通过 &lt;code&gt;--help&lt;/code&gt;，我们可以知道 &lt;code&gt;unoconv&lt;/code&gt; 的用法如下：&lt;/p&gt;
unoconv --stdout --format=html ./docx/test.docx

&lt;p&gt;解析 &lt;code&gt;test.docx&lt;/code&gt; 文件的内容，设置格式为 html，并且输出到标准输出中。&lt;/p&gt;

&lt;h3 id=&#34;使用-shelljs-运行-shell-命令:7f17c56fe3862cd59715dd8ba3bba088&#34;&gt;使用 shelljs 运行 shell 命令&lt;/h3&gt;

&lt;p&gt;这里使用的是熟悉的 nodejs 进行开发，而运行 shell 命令我使用的是 &lt;a href=&#34;https://github.com/arturadib/shelljs&#34;&gt;shelljs&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;
npm install shelljs

&lt;p&gt;使用：&lt;/p&gt;
shelljs.exec(&#39;unoconv --stdout --format=html ./docx/test.docx&#39;, {silent: true}, function (code, result) {
    if (code) {
        console.log(&#39;Error code: &#39; + code);
        return;
    }
    console.log(result);
});

&lt;p&gt;到这里已经可以将 word 的内容输出到 console 中了。&lt;/p&gt;

&lt;h3 id=&#34;使用-jquery-解析-html-内容:7f17c56fe3862cd59715dd8ba3bba088&#34;&gt;使用 jQuery 解析 html 内容&lt;/h3&gt;

&lt;p&gt;可以看到输入的内容为 html 代码，我们需要对其进行处理，这里使用的是熟悉的 &lt;a href=&#34;https://github.com/UncoolAJ86/node-jquery&#34;&gt;jQuery&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;
npm install -S &#39;jquery@&gt;=2.1&#39;
npm install -S &#39;jsdom@latest&#39;

&lt;p&gt;关键代码：&lt;/p&gt;
env(data, function (errors, window) {
    var $ = require(&#39;jquery&#39;)(window);

    $(&#39;p&#39;).each(function (i) {
        var text = $.trim($(this).text());
        // 这里一行一行读取文本，可以根据需要自己解析文本
    });

    $(&#39;img&#39;).each(function (i) {
        var matches = $(this).attr(&#39;src&#39;).match(/^data:image\/([A-Za-z]+);base64,(.+)$/);

        if (matches.length !== 3) {
            return new Error(&#39;Invalid input string&#39;);
        }

        var type = matches[1]; // 图片的类型
        var data = new Buffer(matches[2], &#39;base64&#39;);

        fs.writeFile(&#39;./images/&#39; + i + &#39;.jpg&#39;, data);
        // 将图片保存到 images 中，可以根据需要生成不同的名称
    });
});

&lt;h3 id=&#34;使用-async-批量读取-word-文件:7f17c56fe3862cd59715dd8ba3bba088&#34;&gt;使用 async 批量读取 word 文件&lt;/h3&gt;

&lt;p&gt;假如直接使用 forEach 的话会导致内存溢出，所以我们需要对每个文件进行排队处理，这里使用 &lt;a href=&#34;https://github.com/caolan/async&#34;&gt;async&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;
npm install async

&lt;p&gt;使用：&lt;/p&gt;
fs.readdir(&#39;./docx&#39;, function (err, files) {
    async.eachSeries(files, parse, function () {
        console.log(&#39;OK!!!&#39;);
    });
});

function parse(file, callback) {
    // 处理 file，完成之后调用 callback
}

&lt;p&gt;搞定！！！当然这里只是简单的记录了大概的思路和代码，实际上需要根据不同的需要做对应的处理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何为 NodeJs 设置 Nginx 代理服务器</title>
      <link>http://blog.wenzhixin.net.cn/2014/09/18/nginx_as_proxy_nodejs</link>
      <pubDate>Thu, 18 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/09/18/nginx_as_proxy_nodejs</guid>
      <description>&lt;p&gt;很多时候，我们需要为 NodeJs 设置反向代理，例如本博客后台 NodeJs 的应用监听的端口为 3333，通过 Nginx 便可以轻松代理为 80 端口，那么应该如何设置呢？&lt;/p&gt;

&lt;p&gt;首先设置 &lt;code&gt;upstream&lt;/code&gt;：&lt;/p&gt;
upstream app_blog {
    server 127.0.0.1:3333;
}

&lt;p&gt;设置 &lt;code&gt;server&lt;/code&gt;：&lt;/p&gt;
server {
    listen 80 default;
    server_name wenzhixin.net.cn wenzhixin.*;

    location / {
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-NginX-Proxy true;

        proxy_pass http://app_blog;
        proxy_redirect off;
    }
}

&lt;p&gt;重启 &lt;code&gt;nginx&lt;/code&gt;：&lt;/p&gt;
sudo service nginx restart

&lt;p&gt;大功告成！根据我们的设置，所有通过 80 的请求（头部信息）都会跳转到 3333 端口。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 apache2 作为代理服务器轻松解决 Ajax 跨域问题</title>
      <link>http://blog.wenzhixin.net.cn/2014/06/05/apache_proxy</link>
      <pubDate>Thu, 05 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/06/05/apache_proxy</guid>
      <description>

&lt;h3 id=&#34;介绍:299d40c8bf8f0942a2f38dea542412ab&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;我们知道，使用 JavaScript 进行开发 Ajax 应用的时候会有跨域访问的问题，而用代理便可以解决跨域访问的问题。
那么应该如何开启 apache2 的 http 代理模块呢？&lt;/p&gt;

&lt;p&gt;模块 &lt;a href=&#34;http://www.2cto.com/shouce/ApacheManual/mod/mod_proxy.html&#34;&gt;mod_proxy&lt;/a&gt;实现了Apache的代理/网关。
它实现了以下规范的代理 FTP， CONNECT（用于SSL）， HTTP/0.9， HTTP/1.0，和 HTTP/1.1。
此模块经配置后可用上述或其它协议连接其它代理模块。&lt;/p&gt;

&lt;h3 id=&#34;启动:299d40c8bf8f0942a2f38dea542412ab&#34;&gt;启动&lt;/h3&gt;

&lt;p&gt;在 apache2 的安装目录下，有这样的两个目录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/etc/apache2/mods-enabled/ 已经被启用的模块&lt;/li&gt;
&lt;li&gt;/etc/apache2/mods-available/ 当前系统中可用的模块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以使用下列命令来启用（或禁用）proxy 模块：&lt;/p&gt;
sudo a2enmod proxy
sudo a2enmod proxy_http

sudo a2dismod proxy
sudo a2dismod proxy_http

&lt;p&gt;启用完之后重启 apache 即可：&lt;/p&gt;
sudo service apache restart

&lt;h3 id=&#34;配置:299d40c8bf8f0942a2f38dea542412ab&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;新建配置文件：&lt;/p&gt;
sudo vi /etc/apache2/site-enabled/proxy.conf
&lt;IfModule mod_proxy.c&gt;
	ProxyPass /api http://wenzhixin.net.cn/api
	ProxyPassReverse /api http://wenzhixin.net.cn/api
&lt;/IfModule&gt;

&lt;p&gt;这里使用了 &lt;a href=&#34;http://www.2cto.com/shouce/ApacheManual/mod/mod_proxy.html#proxypass&#34;&gt;ProxyPass&lt;/a&gt; 和 &lt;a href=&#34;http://www.2cto.com/shouce/ApacheManual/mod/mod_proxy.html#proxypassreverse&#34;&gt;ProxyPassReverse&lt;/a&gt; 指令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ProxyPass：将一个远端服务器映射到本地服务器的URL空间中&lt;/li&gt;
&lt;li&gt;ProxyPassReverse：调整由反向代理服务器发送的HTTP回应头中的URL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;保存，重启 apache2。&lt;/p&gt;

&lt;p&gt;到这里，我们就可以通过直接访问 &lt;code&gt;http://127.0.0.1/api&lt;/code&gt;来代理远程服务器的 api 接口了，从而解决了跨域的问题。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;相关问题：&lt;a href=&#34;http://wenzhixin.net.cn/2012/08/01/the_use_of_nginx_as_a_proxy_server_easily_solve_the_cross_domain_ajax_problem&#34;&gt;使用 nginx 作为代理服务器轻松解决 Ajax 跨域问题&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SVN 如何恢复被删除的文件夹</title>
      <link>http://blog.wenzhixin.net.cn/2014/04/24/svn_undelete_folder</link>
      <pubDate>Thu, 24 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/04/24/svn_undelete_folder</guid>
      <description>

&lt;h3 id=&#34;问题:e361e7dd74fd97e49c47e3988690836d&#34;&gt;问题：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;你删除了 SVN 版本库上的文件夹，那么你要怎么恢复呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;尝试办法:e361e7dd74fd97e49c47e3988690836d&#34;&gt;尝试办法：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;svn revert folder&lt;/code&gt;，会发现找不到该文件夹&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;svn merge&lt;/code&gt;，从上个版本恢复回来，但是发现也是有找不到的问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过从上个版本恢复，然后 &lt;code&gt;svn add foler&lt;/code&gt; 到现有版本库中，这样会导致 log 失效，并不是我们想要的&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;最终解决办法:e361e7dd74fd97e49c47e3988690836d&#34;&gt;最终解决办法：&lt;/h3&gt;

&lt;p&gt;通过尝试发现把自己的思路给限死了，有时候就应该这样，换个角度思考问题，
我们所要做的事情很简单，就是恢复文件夹，并且保证 log 的正确性，那么 copy 就能解决这个问题：&lt;/p&gt;
svn copy svn://svnserver/project/tags@100 http://svnserver/project/tags -m &#34;undeleted folder&#34;

&lt;p&gt;表示从 url 为 svn://svnserver/project 的项目中恢复版本号为 100 的 tags 文件夹，并且信息为 &amp;ldquo;undeleted folder&amp;rdquo;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 下搭建 JavaEE 环境</title>
      <link>http://blog.wenzhixin.net.cn/2014/04/02/ubuntu_java_ee</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/04/02/ubuntu_java_ee</guid>
      <description>

&lt;p&gt;在 Ubuntu 下搭建 JavaEE 的环境稍微有些麻烦，这里记录下。&lt;/p&gt;

&lt;h3 id=&#34;1-安装-eclipse-和-tomcat7:2d9f64794b91e20ce48f94cc6b696e20&#34;&gt;1. 安装 eclipse 和 tomcat7&lt;/h3&gt;
sudo apt-get install eclipse
sudo apt-get install tomcat7

&lt;p&gt;注：安装 eclipse 后会把依赖的 jdk 安装好，使用 apt-get 安装的 eclipse 是最精简的版本。&lt;/p&gt;

&lt;h3 id=&#34;2-安装-eclipse-的-javaee-插件:2d9f64794b91e20ce48f94cc6b696e20&#34;&gt;2. 安装 eclipse 的 JavaEE 插件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;依次点击：Help -&amp;gt; Install New Software&amp;hellip; -&amp;gt; Add&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输入：&lt;a href=&#34;http://download.eclipse.org/releases/indigo&#34;&gt;http://download.eclipse.org/releases/indigo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择：Eclipse Java EE Developer Tools、JST Server Adapters、JST Server Adapters Extentions 并进行安装&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启 eclipse&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：不安装 JST Server Adapters 的话，在 Eclipse Server Runtime Environments 选择不了 tomcat&lt;/p&gt;

&lt;h3 id=&#34;3-create-new-server-wizard:2d9f64794b91e20ce48f94cc6b696e20&#34;&gt;3. create new server wizard&lt;/h3&gt;

&lt;p&gt;会出现 &lt;code&gt;Cannot create a server using the selected type&lt;/code&gt; 的问题，解决：&lt;/p&gt;
cd .metadata/.plugins/org.eclipse.core.runtime/.settings/
rm org.eclipse.jst.server.tomcat.core.prefs
rm org.eclipse.wst.server.core.prefs

&lt;p&gt;修改 tomcat7 的配置和文件权限：&lt;/p&gt;
cd /usr/share/tomcat7
sudo ln -s /var/lib/tomcat7/conf conf
sudo ln -s /etc/tomcat7/policy.d/03catalina.policy conf/catalina.policy
sudo ln -s /var/log/tomcat7 log
sudo chmod -R 777 /usr/share/tomcat7/conf

&lt;p&gt;禁用 tomcat7 自启动：&lt;/p&gt;
sudo service tomcat7 stop
sudo update-rc.d tomcat7 disable

&lt;p&gt;注：至此，已经搞定了，假如还有问题那还需要：&lt;/p&gt;
cd /usr/share/tomcat7
sudo ln -s /var/lib/tomcat7/common common
sudo ln -s /var/lib/tomcat7/server server
sudo ln -s /var/lib/tomcat7/shared shared
</description>
    </item>
    
    <item>
      <title>使用 nodejs 发送邮件</title>
      <link>http://blog.wenzhixin.net.cn/2014/01/23/node_send_email</link>
      <pubDate>Thu, 23 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/01/23/node_send_email</guid>
      <description>&lt;p&gt;平时在开发应用的时候，很多时候会用到邮件，来通知我们，
这里介绍 nodejs 如何发送邮件，比较简单。&lt;/p&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://github.com/andris9/Nodemailer&#34;&gt;Nodemailer&lt;/a&gt; 库来发送邮件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;&lt;/p&gt;
npm install nodemailer --save

&lt;p&gt;&lt;strong&gt;增加配置信息 config.js：&lt;/strong&gt;&lt;/p&gt;
module.exports = {
    mail: {
        from: {
            name: &#39;App name&#39;,
            service: &#39;Gmail&#39;,
            auth: {
                user: &#39;gmail.name@gmail.com&#39;,
                pass: &#39;gmail.password&#39;
            }
        },
        to: [
            &#39;Zhixin Wen &lt;wenzhixin2010@gmail.com&gt;&#39;
        ]
    }
};

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;from：配置发送邮件信息&lt;/li&gt;
&lt;li&gt;to：数组，配置发送给谁&lt;/li&gt;
&lt;li&gt;name：显示的名称&lt;/li&gt;
&lt;li&gt;service：SMTP 名称，这里用 Gmail&lt;/li&gt;
&lt;li&gt;auth：邮箱的用户名和密码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何使用：&lt;/strong&gt;&lt;/p&gt;
var nodemailer = require(&#39;nodemailer&#39;),
    config = require(&#39;./config&#39;),
    smtpTransport = nodemailer.createTransport(&#39;SMTP&#39;, config.mail.from);

&lt;p&gt;定义并且根据配置文件生成 smtpTransport。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送邮件函数：&lt;/strong&gt;&lt;/p&gt;
/**
 * @param {String} subject：发送的主题
 * @param {String} html：发送的 html 内容
 */
function sendMail(subject, html) {
    var mailOptions = {
        from: [config.mail.from.name, config.mail.from.auth.user].join(&#39; &#39;),
        to: config.mail.to.join(&#39;,&#39;),
        subject: subject,
        html: html
    };

    smtpTransport.sendMail(mailOptions, function(error, response){
        if (error) {
            console.log(error);
        } else {
            console.log(&#39;Message sent: &#39; + response.message);
        }
        smtpTransport.close();
    });
};

&lt;p&gt;&lt;strong&gt;发邮件例子：&lt;/strong&gt;&lt;/p&gt;
sendMail(&#39;测试发邮件&#39;, &#39;&lt;p&gt;Hello world!&lt;/p&gt;&#39;);
</description>
    </item>
    
    <item>
      <title>PHP 代码规范</title>
      <link>http://blog.wenzhixin.net.cn/2014/01/20/php_code_standard</link>
      <pubDate>Mon, 20 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/01/20/php_code_standard</guid>
      <description>

&lt;h3 id=&#34;通用规范:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;通用规范&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;代码缩进全部用 tab / 四个空格&lt;/li&gt;
&lt;li&gt;SVN / Git 中新建文件编码类型统一用 utf-8 编码&lt;/li&gt;
&lt;li&gt;行宽：80 字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;php-代码划分:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;PHP 代码划分&lt;/h3&gt;

&lt;p&gt;PHP 代码总是用完整的标准的 PHP 标签定界：&lt;/p&gt;
&lt;?php
// 开头必须使用 &lt;?php

// php文件必须以 ?&gt; 结尾，并且保证其后面没有空格或空行。
?&gt;

&lt;h3 id=&#34;注明作者信息:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;注明作者信息&lt;/h3&gt;

&lt;p&gt;每个文件必须注明作者的信息和邮箱&lt;/p&gt;
&lt;?php
/*
 * @author: zhixin &lt;wenzhixin2010@gmail.com&gt;
 */
?&gt;

&lt;h3 id=&#34;字符串文字:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;字符串文字&lt;/h3&gt;

&lt;p&gt;当字符串是文字（不包含变量），应当用单引号（apostrophe）来括起来：&lt;/p&gt;
$a = &#39;Example String&#39;;

&lt;h3 id=&#34;操作符前后都要有空格:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;操作符前后都要有空格&lt;/h3&gt;
$c = $a + $b; // 操作符前后都要有空格

$company = &#39;Zend&#39; . &#39; &#39; . &#39;Technologies&#39;; // 字符串必需用 &#34;.&#34; 操作符连接，在它的前后加上空格以提高可读性

&lt;h3 id=&#34;函数:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;函数&lt;/h3&gt;
function foo($i, $list) { // 定义函数，( 前面没有空格，） 后面需要空格

}

require_once(&#39;config.inc.php&#39;); //  调用函数，() 前后没有空格

threeArguments(1, 2, 3); // 多个参数，如果有逗号，那么逗号后面要有空格

&lt;h3 id=&#34;控制语句:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;控制语句&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用控制语句在语句的圆括号前后都必须有一个空格。&lt;/li&gt;
&lt;/ul&gt;
if ($i &gt; 0) { // if后面加空格

} else { // else前后也要有空格

}

for ($j = 0; $j &lt; $i; $j++) { // for后面加空格

}

switch ($numPeople) { // switch后面加空格
    case 1: // 缩进
        break;

    case 2:
        break;

    default: // switch 语句应当有 default
        break;
}

&lt;h3 id=&#34;数组:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;数组：&lt;/h3&gt;
$number = array(1, 2, 3, 4); // 简单数组，放一行

// 数组格式
$color = array(
    &#39;1&#39; =&gt; &#39;red&#39;, // 缩进一次
    &#39;2&#39; =&gt; &#39;blue&#39;,
    &#39;3&#39; =&gt; &#39;yellow&#39;,
    &#39;4&#39; =&gt; array(
        &#39;1&#39; =&gt; &#39;green&#39;,	// 缩进一次
        &#39;2&#39; =&gt; &#39;gray&#39;
    ) // 数组的结尾与声明的变量最前面对齐
); // 数组的结尾与数组变量声明的地方对齐

&lt;h3 id=&#34;类:ed497f5f7762bd3c3ecc61d8f0720d1b&#34;&gt;类&lt;/h3&gt;
class CodingStandard { // 大括号前面加空格，类名开头字母大写，多个字母首字母大写
    private $attribute; // 命名使用驼峰原则

    public function testFunction() { // 方法命名都遵守驼峰原则

    }
}

$s = new CodingStandard(); // new 一个对象，后面必须加括弧

&lt;hr /&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://framework.zend.com/manual/1.12/zh/coding-standard.coding-style.html&#34;&gt;编码风格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nodeJS 和 Nginx 解决客户端发送大数据的问题</title>
      <link>http://blog.wenzhixin.net.cn/2014/01/18/large_body_error</link>
      <pubDate>Sat, 18 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/01/18/large_body_error</guid>
      <description>&lt;p&gt;nodeJS 和 Nginx 默认情况下都只支持 1MB 的 body 数据，当客户端发送大数据的时候，分别会出现以下错误：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nodeJS：&lt;/strong&gt;&lt;/p&gt;
Error: request entity too large

&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/p&gt;
app.use(express.bodyParser({
    limit: 1024 * 1024 * 64 // 64M
}));

&lt;p&gt;&lt;strong&gt;Nginx：&lt;/strong&gt;&lt;/p&gt;
client intended to send too large body

&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;
在 nginx/nginx.conf 中的 http 下加入&lt;/p&gt;
http {
    ...
    client_max_body_size 64M;
}
</description>
    </item>
    
    <item>
      <title>Nginx rewrite query string</title>
      <link>http://blog.wenzhixin.net.cn/2013/12/31/nginx_rewrite_query_string</link>
      <pubDate>Tue, 31 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/12/31/nginx_rewrite_query_string</guid>
      <description>&lt;p&gt;&lt;strong&gt;rewrite 的正则是不匹配 query string 的&lt;/strong&gt;，
默认情况下，query string 会自动追加到rewrite 后的地址上。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
rewrite ^/read.php$ /api.php

&lt;p&gt;那么：&lt;/p&gt;

&lt;p&gt;访问 read.php?tid=123 的时候实际上已经 rewrite 到了 api.php?tid=123 上了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx 中 $args 变量保存了 query string 中的值&lt;/strong&gt;,
例如 ?tid=123，那么可以使用 $arg_tid 来匹配 tid 的值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而不想自动追加 query string，则在 rewrite 地址的末尾添加 ?&lt;/strong&gt;&lt;/p&gt;
rewrite ^/read.php$ /api.php?tid=$arg_tid&amp;func=post?
</description>
    </item>
    
    <item>
      <title>apache 重写链接</title>
      <link>http://blog.wenzhixin.net.cn/2013/12/31/apache_rewrite</link>
      <pubDate>Tue, 31 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/12/31/apache_rewrite</guid>
      <description>

&lt;h4 id=&#34;安装启用-mod-rewrite:1c9366477c365c5b0e6d0f98aacfd555&#34;&gt;安装启用 mod_rewrite&lt;/h4&gt;

&lt;p&gt;在安装启用之前，编写 info.php 文件&lt;/p&gt;
&lt;?php phpinfo();?&gt;

&lt;p&gt;从浏览器中打开，使用 Ctrl + F 进行查找 mod_rewrite 是否在 Loaded Modules 中，
已经存在就表示我们已经安装，不存在的话，那么，需要进行安装：&lt;/p&gt;
sudo a2enmod rewrite

&lt;p&gt;修改 AllowOverRide 为 AllowOverRide All&lt;/p&gt;
sudo vi /etc/apache2/sites-enabled/default

&lt;h4 id=&#34;使用正则重写链接:1c9366477c365c5b0e6d0f98aacfd555&#34;&gt;使用正则重写链接&lt;/h4&gt;

&lt;p&gt;这里我们将 restfull 的 url 转发为 php 文件。&lt;/p&gt;

&lt;p&gt;新建 .htaccess 文件&lt;/p&gt;
RewriteEngine on
RewriteRule ^/api/.*$ /api.php [L]

&lt;ul&gt;
&lt;li&gt;RewriteEngine：表示启用 rewrite&lt;/li&gt;
&lt;li&gt;RewriteRule：表示这是一条 rewrite 规则&lt;/li&gt;
&lt;li&gt;L：该属性表示规则匹配成功后就不需要匹配其他规则了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 api.php 中，通过下面的变量来获取想要的值&lt;/p&gt;
$request_method = $_SERVER[&#39;REQUEST_METHOD&#39;];
$request_uri = $_SERVER[&#39;REQUEST_URI&#39;];
$request_query = $_GET;
$request_data = file_get_contents(&#39;php://input&#39;);

&lt;h4 id=&#34;迁移网站重写规则:1c9366477c365c5b0e6d0f98aacfd555&#34;&gt;迁移网站重写规则&lt;/h4&gt;

&lt;p&gt;迁移网站的时候，我们需要将旧地址都重写到新地址上去&lt;/p&gt;
RewriteEngine on
RewriteRule ^/old.php$ /new.php [R=301,L]

&lt;p&gt;R=301：该属性表示请求 old.php 的时候返回一个 301 的重定向&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wordpress 打造 CMS 系统小记</title>
      <link>http://blog.wenzhixin.net.cn/2013/12/04/wordpress_cms</link>
      <pubDate>Wed, 04 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/12/04/wordpress_cms</guid>
      <description>

&lt;h3 id=&#34;关闭文章评论:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;关闭文章评论：&lt;/h3&gt;

&lt;p&gt;设置-讨论下，去掉“允许他人在新文章上发表评论”选项&lt;/p&gt;

&lt;h3 id=&#34;关闭页面评论:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;关闭页面评论：&lt;/h3&gt;

&lt;p&gt;到具体页面编辑，打开显示选项中的讨论，去掉“允许评论”选项&lt;/p&gt;

&lt;h3 id=&#34;添加上一篇-下一篇:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;添加上一篇、下一篇：&lt;/h3&gt;

&lt;p&gt;打开 single.php 页面，在 footer 中加入&lt;/p&gt;
&lt;div&gt;
	&lt;div class=&#34;left&#34;&gt;
		&lt;?php if (get_previous_post()) { previous_post_link(&#39;上一篇：%link&#39;); } else { echo &#39;上一篇：没有了！&#39;; }?&gt;
	&lt;/div&gt;
	&lt;div class=&#34;right&#34;&gt;
		&lt;?php if (get_next_post()) { next_post_link(&#39;下一篇：%link&#39;); } else { echo &#39;下一篇：没有了！&#39;; } ?&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;clear&#34;&gt;&lt;/div&gt;

&lt;p&gt;在 style.css 中加入&lt;/p&gt;
.entry-utility .left {
	float: left;
}
.entry-utility .right {
	float: right;
}

&lt;h3 id=&#34;隐藏文章底部分享信息:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;隐藏文章底部分享信息：&lt;/h3&gt;

&lt;p&gt;打开 functions.php，找到 pinboard_social_bookmarks 函数&lt;/p&gt;
function pinboard_social_bookmarks() {
	return false;
}

&lt;h3 id=&#34;自定义首页:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;自定义首页：&lt;/h3&gt;

&lt;p&gt;新建 home.php&lt;/p&gt;
&lt;?php
/*
Template Name: Home
*/
?&gt;
&lt;?php get_header(); ?&gt;
&lt;?php if( is_front_page() ) : ?&gt;
	&lt;?php if( pinboard_get_option( &#39;slider&#39; ) ) : ?&gt;
		&lt;?php get_template_part( &#39;slider&#39; ); ?&gt;
	&lt;?php endif; ?&gt;
	&lt;?php get_sidebar( &#39;wide&#39; ); ?&gt;
	&lt;?php get_sidebar( &#39;boxes&#39; ); ?&gt;
&lt;?php endif; ?&gt;
&lt;div id=&#34;container&#34;&gt;
&lt;/div&gt;
&lt;?php get_footer(); ?&gt;

&lt;p&gt;页面-新建，选择模板 home，标题为首页，内容为空。&lt;/p&gt;

&lt;p&gt;设置-阅读中，首页显示选择“一个静态页面”，主页选择“首页”。&lt;/p&gt;

&lt;h3 id=&#34;添加首页幻灯片:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;添加首页幻灯片：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://wordpress.org/plugins/ml-slider/&#34;&gt;Meta Slider&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载解压到 wp-content/plugins，并启用。&lt;/p&gt;

&lt;p&gt;设置大小为：1140px * 350px&lt;/p&gt;

&lt;p&gt;在 home.php 加入(id 为幻灯片的ID)&lt;/p&gt;
&lt;?php echo do_shortcode(&#34;[metaslider id=id]&#34;); ?&gt;

&lt;h3 id=&#34;其他:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;其他&lt;/h3&gt;

&lt;h4 id=&#34;content-php:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;content.php&lt;/h4&gt;

&lt;p&gt;第1行去掉&lt;/p&gt;
&lt;?php post_class(); ?&gt;

&lt;h4 id=&#34;functions-php:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;functions.php&lt;/h4&gt;

&lt;p&gt;第760行去掉&lt;/p&gt;
$content.imagesLoaded(function() {
	$content.masonry({
		itemSelector : &#39;.hentry, #infscr-loading&#39;,
		columnWidth : container.querySelector(&#39;.&lt;?php echo pinboard_teaser_class(); ?&gt;&#39;),
	});
});
function pinboard_entry_meta () {
}

&lt;p&gt;the_author_link() 改为 the_author()&lt;/p&gt;
&lt;span class=&#34;entry-date&#34;&gt;&lt;span rel=&#34;bookmark&#34; title=&#34;&lt;?php the_title_attribute(); ?&gt;&#34;&gt;&lt;?php the_time( get_option( &#39;date_format&#39; ) ); ?&gt;&lt;/span&gt;&lt;/span&gt;

&lt;p&gt;Permalink 改为 更多&amp;hellip;&lt;/p&gt;
function pinboard_excerpt_length() 改为 return 100;

&lt;h4 id=&#34;sytle-css:8acb684cc5673a49730e1ea02c21df7d&#34;&gt;sytle.css&lt;/h4&gt;

&lt;p&gt;#header #searchform 加上&lt;/p&gt;
display: none;
</description>
    </item>
    
    <item>
      <title>为你的网站开启 gzip 压缩功能（nodejs、nginx）</title>
      <link>http://blog.wenzhixin.net.cn/2013/11/10/server_gzip_on</link>
      <pubDate>Sun, 10 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/11/10/server_gzip_on</guid>
      <description>

&lt;p&gt;开启网站的 gzip 压缩功能，通常可以高达70%，也就是说，如果你的网页有30K，压缩之后就变成9K，
对于大部分网站，显然可以明显提高浏览速度（注：需要浏览器支持）。&lt;/p&gt;

&lt;p&gt;测试工具：&lt;a href=&#34;http://developers.google.com/speed/pagespeed/insights/&#34;&gt;google speed&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;nodejs-express:5b073e0f77dbfbc20f7932700a9b9d58&#34;&gt;nodejs + express&lt;/h4&gt;

&lt;p&gt;对于 nodejs + express 框架，启用方法非常简单，启用 compress() 中间件即可，
通过 gzip / deflate 压缩响应数据，这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
app.use(express.logger());
app.use(express.compress());
app.use(express.static(__dirname + &#39;/html&#39;));
app.use(express.methodOverride());
app.use(express.bodyParser());

&lt;h4 id=&#34;nginx:5b073e0f77dbfbc20f7932700a9b9d58&#34;&gt;nginx&lt;/h4&gt;

&lt;p&gt;编辑 nginx 的配置文件&lt;/p&gt;
sudo vi /etc/nginx/nginx.conf

&lt;p&gt;在 Gzip Settings 中加入如下设置：&lt;/p&gt;
##
# Gzip Settings
##

gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_comp_level 5;
gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;

&lt;p&gt;1) gzip&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法：gzip on/off&lt;/li&gt;
&lt;li&gt;默认值：off&lt;/li&gt;
&lt;li&gt;作用域：http, server, location&lt;/li&gt;
&lt;li&gt;说明：开启或者关闭 gzip 模块，这里使用 on 表示启动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2) gzip_min_length&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法：gzip_min_length length&lt;/li&gt;
&lt;li&gt;默认值：gzip_min_length 0&lt;/li&gt;
&lt;li&gt;作用域：http, server, location&lt;/li&gt;
&lt;li&gt;说明：设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。|&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3) gzip_buffers&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法: gzip_buffers number size&lt;/li&gt;
&lt;li&gt;默认值: gzip_buffers 4 4k/8k&lt;/li&gt;
&lt;li&gt;作用域: http, server, location&lt;/li&gt;
&lt;li&gt;说明：设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k 代表以 16k 为单位，按照原始数据大小以 16k 为单位的4倍申请内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4) gzip_comp_level&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法: gzip_comp_level 1..9&lt;/li&gt;
&lt;li&gt;默认值: gzip_comp_level 1&lt;/li&gt;
&lt;li&gt;作用域: http, server, location&lt;/li&gt;
&lt;li&gt;说明：gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）。这里设置为 5。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5) gzip_types&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法: gzip_types mime-type [mime-type &amp;hellip;]&lt;/li&gt;
&lt;li&gt;默认值: gzip_types text/html&lt;/li&gt;
&lt;li&gt;作用域: http, server, location&lt;/li&gt;
&lt;li&gt;说明：匹配MIME类型进行压缩，（无论是否指定）&amp;rdquo;text/html&amp;rdquo; 类型总是会被压缩的。这里设置为 text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>RSS、Atom、Feed 介绍与简单实现</title>
      <link>http://blog.wenzhixin.net.cn/2013/11/08/rss_atom_feed_php</link>
      <pubDate>Fri, 08 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/11/08/rss_atom_feed_php</guid>
      <description>

&lt;p&gt;最近接触了 RSS 订阅相关的，做了一些了解与开发，记录下。&lt;/p&gt;

&lt;h4 id=&#34;rss是什么:ff4596b028a60c1dc5123ad61a0f7a25&#34;&gt;RSS是什么&lt;/h4&gt;

&lt;p&gt;RSS（全称RDF Site Summary，网景的最初定义），RSS也是一种“类网页”描述语言（或叫文档格式），
最初由网景公司（Netscape）定义，RSS只是有个相对统一的规范（注意只是规范），
前途未卜（RSS 2.0的版权问题）。RSS作为网站内容分享的一种便利接口，只是从博客（BLOG）风行才开始广为流传。&lt;/p&gt;

&lt;p&gt;关于RSS的更多介绍请参考&lt;a href=&#34;http://zh.wikipedia.org/zh-cn/RSS&#34;&gt;RSS&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;atom是什么:ff4596b028a60c1dc5123ad61a0f7a25&#34;&gt;ATOM是什么&lt;/h4&gt;

&lt;p&gt;由于RSS前途未卜，而且RSS标准发展存在诸多问题或不足，于是ATOM横空出世，可理解为RSS的替代品。
ATOM是IETF的建议标准，Atom Syndication Format是基于XML格式，Atom Publishing Protocol则是基于HTTP协议格式。&lt;/p&gt;

&lt;p&gt;RSS与ATOM比较，请参考：&lt;a href=&#34;http://zh.wikipedia.org/wiki/Atom&#34;&gt;ATOM&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;feed是什么:ff4596b028a60c1dc5123ad61a0f7a25&#34;&gt;FEED是什么&lt;/h4&gt;

&lt;p&gt;FEED只是一个中间过程，所以全世界没人能给FEED下一个准确的定义，所以大家不用关心FEED的定义，其实FEED什么都不是。
如果非得给个说法，最好还是放到英文环境下理解似乎更加合理，FEED其实就是RSS（或ATOM）和订阅用户之间的“中间商”，
起到帮忙批发传递信息的作用。所以，FEED的常见格式就是RSS和ATOM，网络上说的FEED订阅，更确切的说法应该仍然是RSS或ATOM订阅。&lt;/p&gt;

&lt;p&gt;FEED更多介绍：&lt;a href=&#34;http://en.wikipedia.org/wiki/Feed&#34;&gt;Feed&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;可用的工具:ff4596b028a60c1dc5123ad61a0f7a25&#34;&gt;可用的工具&lt;/h4&gt;

&lt;p&gt;RSS Feed 检验网站：&lt;a href=&#34;http://feedvalidator.org&#34;&gt;feedvalidator&lt;/a&gt;。可以检验你的 RSS 是否符合标准，假如不符合会给出相应的提示和警告。&lt;/p&gt;

&lt;p&gt;RSS托管服务网站：&lt;a href=&#34;http://feedburner.google.com&#34;&gt;feedburner&lt;/a&gt;。 网站定位：全球最大的RSS托管服务网站。07年被google以1亿美元收购，现在已迁移到Google域名之下。&lt;/p&gt;

&lt;h4 id=&#34;php-简单实现:ff4596b028a60c1dc5123ad61a0f7a25&#34;&gt;php 简单实现&lt;/h4&gt;

&lt;p&gt;feed.php&lt;/p&gt;
&lt;?php

class Feed {

    protected $entries = array();

    protected $title;
    protected $url;
    protected $updated;
    protected $author;

    public function title($title) {
        $this-&gt;title = $title;
        return $this;
    }

    public function url($url) {
        $this-&gt;url = $url;
        return $this;
    }

    public function updated($updated) {
        $this-&gt;updated = $updated;
        return $this;
    }

    public function author($author) {
        $this-&gt;author = $author;
        return $this;
    }

    public function addEntry($entry) {
        $this-&gt;entries[] = $entry;
        return $this;
    }

    public function __toString() {
        $result = &#39;&lt;?xml version=&#34;1.0&#34;&gt;&#39;;
        $result .= &#39;&lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34;&gt;&#39;;
        $result .= &#39;&lt;title&gt;&#39; . $this-&gt;title . &#39;&lt;/title&gt;&#39;;
        $result .= &#39;&lt;link href=&#34;&gt;&#39; . $this-&gt;url . &#39;&#34; /&gt;&#39;;
        $result .= &#39;&lt;updated&gt;&#39; . $this-&gt;updated . &#39;&lt;/updated&gt;&#39;;
        $result .= &#39;&lt;author&gt;&#39; . $this-&gt;author . &#39;&lt;/author&gt;&#39;;

        foreach ($this-&gt;entries as $entry) {
            $result .= $entry;
        }

        return $result;
    }
}

class Entry {
    protected $title;
    protected $url;
    protected $updated;
    protected $author;
    protected $description;

    public function title($title) {
        $this-&gt;title = $title;
        return $this;
    }

    public function url($url) {
        $this-&gt;url = $url;
        return $this;
    }

    public function updated($updated) {
        $this-&gt;updated = $updated;
        return $this;
    }

    public function author($author) {
        $this-&gt;author = $author;
        return $this;
    }

    public function description($description) {
        $this-&gt;description = $description;
        return $this;
    }

    public function __toString() {
        $result .= &#39;&lt;entry&gt;&#39;;
        $result .= &#39;&lt;title&gt;&#39; . $this-&gt;title . &#39;&lt;/title&gt;&#39;;
        $result .= &#39;&lt;link href=&#34;&gt;&#39; . $this-&gt;url . &#39;&#34; /&gt;&#39;;
        $result .= &#39;&lt;updated&gt;&#39; . $this-&gt;updated . &#39;&lt;/updated&gt;&#39;;
        $result .= &#39;&lt;author&gt;&#39; . $this-&gt;author . &#39;&lt;/author&gt;&#39;;
        $result .= &#39;&lt;description&gt;&#39; . $this-&gt;description . &#39;&lt;/description&gt;&#39;;
        $result .= &#39;&lt;/entry&gt;&#39;;
        return $result;
    }
}
?&gt;

&lt;p&gt;test.php&lt;/p&gt;
&lt;?php
require_once &#39;feed.php&#39;;

$feed = new Feed();
$feed-&gt;title(&#39;文翼的博客&#39;)
    -&gt;url(&#39;http://wenzhixin.net.cn&#39;)
    -&gt;updated(date(&#39;Y-m-d H:i:s&#39;, time()))
    -&gt;author(&#39;wenzhixin&#39;);
echo $feed;

$entry = new Entry();
$entry-&gt;title(&#39;文章1&#39;)
    -&gt;description(&#39;这里是文章1的内容&#39;)
    -&gt;url(&#39;http://wenzhixin.net.cn/1&#39;)
    -&gt;updated(&#39;2013-11-08 22:55:00&#39;)
    -&gt;author(&#39;wenzhixin&#39;);
$feed-&gt;addEntry($entry);

$entry = new Entry();
$entry-&gt;title(&#39;文章2&#39;)
    -&gt;description(&#39;这里是文章2的内容&#39;)
    -&gt;url(&#39;http://wenzhixin.net.cn/2&#39;)
    -&gt;updated(&#39;2013-11-07 11:33:00&#39;)
    -&gt;author(&#39;wenzhixin&#39;);
$feed-&gt;addEntry($entry);

echo $feed;
?&gt;
</description>
    </item>
    
    <item>
      <title>nginx 开启 http 下载服务器认证</title>
      <link>http://blog.wenzhixin.net.cn/2013/10/19/nginx_http_auth</link>
      <pubDate>Sat, 19 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/10/19/nginx_http_auth</guid>
      <description>

&lt;h4 id=&#34;1-介绍:5697f69a7ab129c553754cdfa6ec4167&#34;&gt;1. 介绍&lt;/h4&gt;

&lt;p&gt;有时候，我们需要提供下载服务器给别人文件，但是又不想给所有人看到，从而保证安全性。
这种时候，对目录访问进行认证，并且每天改变随机密码，共享的时候提供地址、用户名和密码就可以了。&lt;/p&gt;

&lt;h4 id=&#34;2-nginx-设置:5697f69a7ab129c553754cdfa6ec4167&#34;&gt;2. nginx 设置&lt;/h4&gt;

&lt;p&gt;1) 设置 nginx 的配置文件（/etc/nginx/sites-enabled/default）：&lt;/p&gt;
location /download/ {
    # 下载目录为 /home/myname/download
    root /home/myname;

    # 设置目录浏览
    autoindex on;

    # 默认为on，显示出文件的确切大小，单位是bytes。
    # 改为off后，显示出文件的大概大小，单位是kB或者MB或者GB
    autoindex_exact_size off;

    # 默认为off，显示的文件时间为GMT时间
    # 注意:改为on后，显示的文件时间为文件的服务器时间
    autoindex_localtime on;

    # 在第一次访问目录时，会弹出输入验证框
    auth_basic &#34;Restricted&#34;;

    # 存放密码的文件，/etc/nginx/passwd/download
    auth_basic_user_file passwd/download;

    # 设置charset，解决中文乱码问题
    charset utf-8,gbk;
}

&lt;p&gt;2) 生成密码文件：&lt;/p&gt;
sudo mkdir /etc/nginx/passwd
sudo chmod 777 /etc/nginx/passwd
sudo vi /etc/nginx/passwd/download
sudo chmod 777 /etc/nginx/passwd/download

&lt;p&gt;输入用户名和密码（密码会在第三步被替换）：&lt;/p&gt;
admin: admin

&lt;ul&gt;
&lt;li&gt;admin 为自己使用的用户名密码&lt;/li&gt;
&lt;li&gt;guest 提供给他人使用的用户名和密码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3) 设置 admin 的密码（apt-get install apache2-utils）：&lt;/p&gt;
sudo htpasswd /etc/nginx/passwd/download admin

&lt;p&gt;4) 重启 nginx 就可以了：&lt;/p&gt;
sudo service nginx restart

&lt;h4 id=&#34;3-每天随机生成-guest-密码:5697f69a7ab129c553754cdfa6ec4167&#34;&gt;3. 每天随机生成 guest 密码&lt;/h4&gt;

&lt;p&gt;1) 编写 shell 脚本（random_password.sh）：&lt;/p&gt;
#!/bin/bash

passwd=`cat /dev/urandom | head -1 | md5sum | head -c 6`
echo guest $passwd &gt; /home/myname/download/password.txt
htpasswd -b /etc/nginx/passwd/download guest $passwd

&lt;p&gt;2) 编辑 crontab：&lt;/p&gt;
crontab -e

&lt;p&gt;添加内容：&lt;/p&gt;
0 0 * * * random_password.sh

&lt;p&gt;3) 登录查看密码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yourhost/download/password.txt&#34;&gt;http://yourhost/download/password.txt&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nginx 安装与配置详解</title>
      <link>http://blog.wenzhixin.net.cn/2013/09/21/nginx_install_settings</link>
      <pubDate>Sat, 21 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2013/09/21/nginx_install_settings</guid>
      <description>

&lt;h4 id=&#34;安装-需要支持-php:423122f9103bca93beea633033533e7b&#34;&gt;安装（需要支持 php）：&lt;/h4&gt;
sudo apt-get install nginx
sudo apt-get install php5-fpm

&lt;h4 id=&#34;nginx-的基本配置-etc-nginx-nginx-conf-与参数说明:423122f9103bca93beea633033533e7b&#34;&gt;nginx 的基本配置（/etc/nginx/nginx.conf）与参数说明：&lt;/h4&gt;
# 运行用户 www-data
user www-data;
# 启动进程,通常设置成和 cpu 的数量相等
worker_processes 4;
# PID文件
pid /var/run/nginx.pid;

# 工作模式及连接数上限
events {
    # epoll是多路复用IO(I/O Multiplexing)中的一种方式,
    # 仅用于linux2.6以上内核,可以大大提高nginx的性能
    use epoll;

    # 单个后台worker process进程的最大并发链接数
    worker_connections 768;

    # 是否允许在得到一个新连接的通知时，接收尽可能更多的连接
    # multi_accept on;
}

http {

    # 指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，
    # 对于普通应用，必须设为 on,
    # 如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，
    # 以平衡磁盘与网络I/O处理速度，降低系统的uptime。
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    # 连接超时时间
    keepalive_timeout 65;

    # 设定mime类型,类型由mime.type文件定义
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    #设定日志格式
    log_format main &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;
                    &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;
                    &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;

    # 全局错误日志
    access_log /var/log/nginx/access.log main;
    error_log /var/logs/error.log;

    # 开启 gzip 压缩
    gzip on;
    gzip_disable &#34;MSIE [1-6].&#34;;

    gzip_vary off;
    gzip_comp_level 6;
    gzip_buffers 4 16k;
    gzip_http_version 1.1;
    gzip_min_length 1k;
    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;

    # 设定请求缓冲
    client_header_buffer_size 128k;
    large_client_header_buffers 4 128k;

    # 设定虚拟主机配置
    server {
        # 侦听80端口
        listen 80;
        # server 名称
        server_name wenzhixin.net.cn;

        # 定义服务器的默认网站根目录位置
        root /var/www;

        # 默认请求
        location / {
            #定义首页索引文件的名称
            index index.php index.html index.htm;
            try_files $uri $uri/ /index.php;

            # 假如目录或者文件不存在，重写规则到 api.php 中
            if (!-e $request_filename) {
                rewrite ^(.*)$ /api.php?url=$1 last;
            }
        }

        # 定义错误提示页面
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
        }

        # 静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static|sea-module)/ {
            # 过期30天，静态文件不怎么更新，过期可以设大一点，
            # 如果频繁更新，则可以设置得小一点。
            expires 30d;
        }

        # PHP 脚本请求全部转发到 fastcgi 来处理。
        location ~ .php$ {
            fastcgi_pass 127.0.0.1:9001;
            fastcgi_index index.php;
            fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
            include fastcgi_params;

            fastcgi_buffer_size 128k;
            fastcgi_buffers 4 256k;
            fastcgi_busy_buffers_size 256k;
        }

        # 禁止访问 .htxxx 文件
            location ~ /.ht {
            deny all;
        }

        # 代理设置
        location /proxy {
            proxy_pass http://wenyi.tk;
            access_log off;
        }
    }
}

&lt;h4 id=&#34;php-fpm-的基本配置-etc-php5-fpm-php-fpm-conf-与参数说明:423122f9103bca93beea633033533e7b&#34;&gt;php-fpm 的基本配置（/etc/php5/fpm/php-fpm.conf）与参数说明：&lt;/h4&gt;
# PID 设置
pid = /var/run/php-fpm.pid

# 错误日志
error_log = /var/log/php-fpm.log

# 错误级别。s可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）。s默认: notice。
log_level = notice

# 表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。
emergency_restart_threshold = 60
emergency_restart_interval = 60s

# 设置子进程接受主进程复用信号的超时时间。可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒)。默认值: 0。
process_control_timeout = 0

# 后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。这些设置可以针对每个进程池单独设置。
daemonize = yes

# fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: &#39;ip:port&#39;, &#39;port&#39;, &#39;/path/to/unix/socket&#39;。每个进程池都需要设置。
listen = 127.0.0.1:9001

# backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。
listen.backlog = -1

# 允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔。如果没有设置或者为空，则允许任何服务器请求连接
listen.allowed_clients = 127.0.0.1

listen.owner = www
listen.group = www
listen.mode = 0666

# 启动进程的帐户和组
user = www
group = www

# 如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：
pm = dynamic

pm.max_children # 子进程最大数
pm.start_servers # 启动时的进程数
pm.min_spare_servers # 保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程
pm.max_spare_servers # 保证空闲进程数最大值，如果空闲进程大于此值，此进行清理

# 设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 &#39;0&#39; 则一直接受请求。等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值: 0。
pm.max_requests = 1000

# FPM状态页面的网址。如果没有设置, 则无法访问状态页面。默认值: none。munin监控会使用到
pm.status_path = /status

# FPM监控页面的ping网址。如果没有设置, 则无法访问ping页面。该页面用于外部检测FPM是否存活并且可以响应请求。请注意必须以斜线开头 (/)。
ping.path = /ping

# 用于定义ping请求的返回相应。返回为 HTTP 200 的 text/plain 格式文本。默认值: pong。
ping.response = pong

# 设置单个请求的超时中止时间。该选项可能会对php.ini设置中的&#39;max_execution_time&#39;因为某些特殊原因没有中止运行的脚本有用。设置为 &#39;0&#39; 表示 &#39;Off&#39;.当经常出现502错误时可以尝试更改此选项。
request_terminate_timeout = 0

# 当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中。设置为 &#39;0&#39; 表示 &#39;Off&#39;
request_slowlog_timeout = 10s

# 慢请求的记录日志,配合request_slowlog_timeout使用
slowlog = log/$pool.log.slow

# 设置文件打开描述符的rlimit限制。默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。
rlimit_files = 1024

# 设置核心rlimit最大限制值。可用值: &#39;unlimited&#39; 、0或者正整数。默认值: 系统定义值。
rlimit_core = 0

# 启动时的Chroot目录。所定义的目录需要是绝对路径。如果没有设置, 则chroot不被使用。
chroot =

# 设置启动目录，启动时会自动Chdir到该目录。所定义的目录需要是绝对路径。默认值: 当前目录，或者/目录（chroot时）
chdir =

# 重定向运行过程中的stdout和stderr到主要的错误日志文件中。如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null 。默认值: 空。
catch_workers_output = yes

&lt;p&gt;注：
安装完后，需要修改 listen = 127.0.0.1:9001&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>