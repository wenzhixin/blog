<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端技术 on 文翼的博客</title>
    <link>http://blog.wenzhixin.net.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 前端技术 on 文翼的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>wenzhixin.net.cn 粤ICP备15117953号</copyright>
    <lastBuildDate>Mon, 11 Jan 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.wenzhixin.net.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>通过 css 设置图片的高度与宽度相等</title>
      <link>http://blog.wenzhixin.net.cn/2016/01/11/css_height_equals_width_with_css</link>
      <pubDate>Mon, 11 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2016/01/11/css_height_equals_width_with_css</guid>
      <description>&lt;p&gt;在图片长宽不相等的情况下，想将长宽设置为相等并且自适应屏幕，可以通过 js 的方式进行设置并通过监听 resize 来实时更新，但是这种方式很麻烦。&lt;/p&gt;

&lt;p&gt;这里通过 css 来达到我们想要的效果：&lt;/p&gt;

&lt;p&gt;HTML:&lt;/p&gt;
&lt;div class=&#39;box&#39;&gt;
	&lt;img src=&#34;...&#34;&gt;
&lt;/div&gt;

&lt;p&gt;需要添加一个父元素来达到我们的目的。&lt;/p&gt;

&lt;p&gt;CSS:&lt;/p&gt;
.box {
	position: relative;
	width: 50%;		/* desired width */
}
.box:before {
	content: &#34;&#34;;
	display: block;
	padding-top: 100%; 	/* initial ratio of 1:1*/
}

&lt;p&gt;我们在这里定义了一个伪元素并且将其 &lt;code&gt;padding-top&lt;/code&gt; 设置为 100%，因为这里的 padding-top 是相对于元素的 width 的。&lt;/p&gt;

&lt;p&gt;现在我们定义了一个 &lt;code&gt;.box&lt;/code&gt; 元素，它的长和宽是相等的，现在我们只需要设置 img 的 CSS 即可:&lt;/p&gt;
.box img {
	position:  absolute;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
}
</description>
    </item>
    
    <item>
      <title>react-memory：基于 nodejs &#43; bower &#43; react 的文字记忆游戏</title>
      <link>http://blog.wenzhixin.net.cn/2015/06/07/react_memory</link>
      <pubDate>Sun, 07 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2015/06/07/react_memory</guid>
      <description>

&lt;h3 id=&#34;前言:126e5f0c3267828479b5a765d781e066&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;现在最热门的前端框架，毫无疑问是 &lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;，React 是由 Facebook 出品的 JavaScript 框架，由于该框架比较新，比较少中文的资料。这几天看了很多篇关于 react 的英文文章，不得不说 React 是创建大型、快速的 Web 应用的最好方式。在本文中，我们将通过一步一步的创建一个简单的文字记忆游戏，来体验 React 的思想和强大之处。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 由于对 React 的学习也是皮毛，但是在这里，我希望这个小游戏能够成为学习 React 的最佳开发结构，并且随着自己的不断学习，将会继续改进和完善这里的代码。假如您有任何的建议和反馈，请给我留言，谢谢！&lt;/p&gt;

&lt;p&gt;在开始之前我们先来看看我们的 &lt;a href=&#34;http://demos.wenzhixin.net.cn/react-memory&#34;&gt;demo&lt;/a&gt;，游戏非常简单，输入想要记忆的文字，然后点击开始记忆即可。试玩了我们的游戏之后，那么现在就开始吧。&lt;/p&gt;

&lt;p&gt;先来看看我们的目录结构，你可以在 GitHub 上找到相对应的&lt;a href=&#34;https://github.com/wenzhixin/react-memory&#34;&gt;源码&lt;/a&gt;：&lt;/p&gt;
├── bower_components
│   ├── bootstrap
│   └── jquery
├── node_modules
│   ├── browserify
│   ├── lodash
│   ├── react
│   ├── reactify
│   └── watchify
├── docs
│   ├── component.dot
│   └── component.png
├── build
│   └── app.js
├── css
│   └── style.css
├── index.html
├── js
│   ├── app.js
│   ├── board.js
│   ├── game.js
│   ├── status.js
│   ├── tile.js
│   └── word-form.js
├── bower.json
├── package.json
└── README.md

&lt;ul&gt;
&lt;li&gt;bower_components 和 bower.json 是安装 bower 组件的目录和配置信息。&lt;/li&gt;
&lt;li&gt;node_modules 和 package.json 是安装 npm 模块的目录和配置信息。&lt;/li&gt;
&lt;li&gt;docs 用于存放我们的文档信息。&lt;/li&gt;
&lt;li&gt;css 和 js 用于存放样式和 JavaScript 源码。&lt;/li&gt;
&lt;li&gt;build 用于存放最后编译的 css 和 js 文件。&lt;/li&gt;
&lt;li&gt;index.html 是我们游戏的主页面，也就是 React 的入口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;初始化:126e5f0c3267828479b5a765d781e066&#34;&gt;初始化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;首先，创建 npm 模块的配置文件 package.json&lt;/li&gt;
&lt;/ul&gt;
{
    &#34;name&#34;: &#34;react-memory&#34;,
    &#34;version&#34;: &#34;1.0.0&#34;,
    &#34;description&#34;: &#34;基于 nodejs + bower + react 的文字记忆游戏。&#34;,
    &#34;browserify&#34;: {
        &#34;transform&#34;: [
            [&#34;reactify&#34;]
        ]
    },
    &#34;author&#34;: &#34;wenzhixin &lt;wenzhixin2010@gmail.com&gt; (http://wenzhixin.net.cn/)&#34;,
    &#34;license&#34;: &#34;MIT&#34;
}

&lt;ul&gt;
&lt;li&gt;接着，创建 bower 组件的配置文件 bower.json&lt;/li&gt;
&lt;/ul&gt;
{
    &#34;name&#34;: &#34;react-memory&#34;,
    &#34;version&#34;: &#34;1.0.0&#34;,
    &#34;authors&#34;: [
        &#34;zhixin &lt;wenzhixin2010@gmail.com&gt;&#34;
    ],
    &#34;license&#34;: &#34;MIT&#34;,
    &#34;ignore&#34;: [
        &#34;**/.*&#34;,
        &#34;node_modules&#34;,
        &#34;bower_components&#34;,
        &#34;test&#34;,
        &#34;tests&#34;
    ]
}

&lt;ul&gt;
&lt;li&gt;安装所需要的依赖包&lt;/li&gt;
&lt;/ul&gt;
# 运行游戏时需要的依赖包
npm install --save react lodash
bower install --save bootstrap

# 编译游戏时需要的依赖包
npm install --save-dev browserify watchify reactify

# 全局命令行工具
npm install -g browserify watchify http-server

&lt;p&gt;可以看到，我们安装了运行游戏时所需要的依赖包：react，&lt;a href=&#34;https://github.com/lodash/lodash/&#34;&gt;lodash&lt;/a&gt; 模块，以及 &lt;a href=&#34;https://github.com/twbs/bootstrap&#34;&gt;bootstrap&lt;/a&gt; 组件，lodash 是一个非常实用的工具库，游戏中我们使用到了好多它所提供的操作 array 的简单方法，react 和 bootstrap 的话就不用说了。&lt;/p&gt;

&lt;h3 id=&#34;react-组件依赖层次:126e5f0c3267828479b5a765d781e066&#34;&gt;React 组件依赖层次&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/wenzhixin/react-memory/raw/master/docs/component.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;React 中都是以组件的方式来体现的，从上往下，我们切割成非常小、功能单一的组件，分别是：
* Game：游戏组件
* WordForm：文字输入组价
* Board：游戏面板组件
* Status：游戏状态组价
* Tile：单个卡片组件&lt;/p&gt;

&lt;h3 id=&#34;组件模板:126e5f0c3267828479b5a765d781e066&#34;&gt;组件模板&lt;/h3&gt;

&lt;p&gt;由于我们使用了 nodejs 的开发方式以及 React 独有的 JSX 语法，我们组件的模板为：&lt;/p&gt;
var React = require(&#39;react&#39;), // 加载 react 模块
    _ = require(&#39;lodash&#39;), // 加载 lodash 模块
    OtherComponent = require(&#39;./other-component&#39;); // 加载其他自定义 React 模块

var Component = React.createClass({
    // 定义组件所需要的 properties 属性
    propTypes: {
        prop1: React.PropTypes.string.isRequired,
        func1: React.PropTypes.func.isRequired
    },
    // 初始化组件的状态，并非所有组件都需要 state
    getInitialState: function () {
        return {};
    },
    // 渲染我们的界面
    render: function () {
        return (
            &lt;OtherComponent prop1={this.props.prop1} func1={{this.props.func1}} /&gt;
        );
    }
});

module.exports = Component;

&lt;p&gt;对于各行代码的意思，已加了详细的注释说明，在下面的 js 代码中，也是一样在代码中做了详细注释，由于我们只关注组件的核心部分，与模板相同的地方，我们就不做解释了。&lt;/p&gt;

&lt;h3 id=&#34;game:126e5f0c3267828479b5a765d781e066&#34;&gt;Game&lt;/h3&gt;

&lt;p&gt;创建文件：&lt;code&gt;js/game.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;),
    _ = require(&#39;lodash&#39;),
    Board = require(&#39;./board&#39;),
    WordForm = require(&#39;./word-form&#39;);

var Game = React.createClass({
    // 初始化 state，这里我们使用了 words 数组，用于保存输入的文字
    getInitialState: function () {
        return {words: undefined};
    },
    // 开始游戏
    startGame: function (words) {
        this.setState({
            // 组合并打乱输入的文字
            words: _.shuffle(words.concat(words))
        });
    },
    // 结束游戏，设置 words 为 undefined
    endGame: function () {
        this.setState({words: undefined});
    },
    // 根据 words 来显示我们自定义的组件
    render: function () {
        return (
            this.state.words ?
                &lt;Board onEndGame={this.endGame} words={this.state.words}/&gt; :
                &lt;WordForm onWordsEntered={this.startGame} /&gt;
        );
    }
});

module.exports = Game;

&lt;h3 id=&#34;wordform:126e5f0c3267828479b5a765d781e066&#34;&gt;WordForm&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新建文件：&lt;code&gt;js/word-form.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
var React = require(&#39;react&#39;),
    _ = require(&#39;lodash&#39;);

var WordForm = React.createClass({
    // 需要提供 onWordsEntered 方法，用于触发提交方法，在 Game 中我们使用了 startGame
    propTypes: {
        onWordsEntered: React.PropTypes.func.isRequired
    },
    // 初始化 error 状态
    getInitialState: function () {
        return {error: undefined};
    },
    // 显示错误信息，2s 后自动消失
    setError: function (msg) {
        this.setState({error: msg});
        setTimeout(function () {
            this.setState({error: &#39;&#39;});
        }.bind(this), 2000);
    },
    // 提交文字信息，判断是否符合条件
    submitWords: function (e) {
        e.preventDefault();

        var node = this.refs.words.getDOMNode(),
            // unique 用于生成唯一的字符
            words = _.unique((node.value || &#39;&#39;).trim().split(&#39;&#39;));

        if (words.length &lt; 3) {
            this.setError(&#39;请至少输入三个不同的字符！&#39;);
        } else {
            this.props.onWordsEntered(words);
            node.value = &#39;&#39;;
        }
    },
    render: function () {
        return (
            &lt;form className=&#39;form-inline&#39; onSubmit={this.submitWords}&gt;
                &lt;span&gt;请输入你想记忆的字符：&lt;/span&gt;
                &lt;input className=&#39;form-control&#39; type=&#39;text&#39; ref=&#39;words&#39; maxLength=&#39;10&#39;
                    defaultValue=&#39;文字记忆游戏&#39; /&gt;
                &lt;button className=&#39;btn btn-default&#39; type=&#39;submit&#39;&gt;开始记忆&lt;/button&gt;
                &lt;p className=&#39;error&#39;&gt;{this.state.error}&lt;/p&gt;
            &lt;/form&gt;
        );
    }
});

module.exports = WordForm;

&lt;ul&gt;
&lt;li&gt;由于用用到了 bootstrap 的样式和自定义了 error 样式，需要创建 &lt;code&gt;css/style.css&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;
@import &#34;../bower_components/bootstrap/dist/css/bootstrap.min.css&#34;;

.error {
    color: red;
}

&lt;h3 id=&#34;boar:126e5f0c3267828479b5a765d781e066&#34;&gt;Boar&lt;/h3&gt;

&lt;p&gt;新建文件：&lt;code&gt;js/board.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;),
    _ = require(&#39;lodash&#39;),
    Tile = require(&#39;./tile&#39;),
    Status = require(&#39;./status&#39;);

var Board = React.createClass({
    // 需要提供 words 属性，以及 onEndGame 方法，分别对应 Game 的属性和方法
    propTypes: {
        words: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
        onEndGame: React.PropTypes.func.isRequired
    },
    // 在组件还未 mount 之前用于计算总共有多少对文字卡片
    componentWillMount: function () {
        this.max = this.props.words.length / 2;
    },
    // State 状态
    // found：表示找到了多少对文字卡片
    // message：显示当前的状态
    // tileStates
    getInitialState: function () {
        return {
            found: 0,
            message: &#39;chooseTile&#39;,
            tileStates: new Array(this.props.words.length + 1).join(&#39;unturned &#39;).trim().split(&#39; &#39;)
        };
    },
    // 游戏逻辑的处理方法
    clickedTile: function (index) {
        // 当卡片的状态为 unturned（未翻转）时，才进行处理
        if (this.state.tileStates[index] === &#39;unturned&#39;) {
            // flippedTile 用于保存上个点击的卡片的 index
            if (this.flippedTile === undefined) {
                this.flippedTile = index;
                // 设置状态为 findMate
                this.setState({
                    message: &#39;findMate&#39;,
                    // 使用 lodash 方法，将对应的下标置为 revealed（翻转）状态
                    tileStates: _.extend(this.state.tileStates, _.object([index], [&#39;revealed&#39;]))
                });
            } else {
                var otherIndex = this.flippedTile,
                    matched = this.props.words[index] === this.props.words[this.flippedTile];

                if (matched) {
                    // 找到相对应的卡片，found + 1，并将状态置为 foundMate
                    this.setState({
                        found: this.state.found + 1,
                        message: &#39;foundMate&#39;,
                        // 使用 lodash 方法，将对应的下标置为 correct（正确）状态
                        tileStates: _.extend(this.state.tileStates,
                            _.object([index, otherIndex], [&#39;correct&#39;, &#39;correct&#39;]))
                    });
                } else {
                    // 没有找到相对应的卡片，将状态置为 wrong
                    this.setState({
                        message: &#39;wrong&#39;,
                        // 使用 lodash 方法，将对应的下标置为 wrong（错误）状态
                        tileStates: _.extend(this.state.tileStates,
                            _.object([index, otherIndex], [&#39;wrong&#39;, &#39;wrong&#39;]))
                    });
                }
                // 删除保存的信息
                delete this.flippedTile;

                // 1.5s 后我们将卡片翻转回来
                setTimeout(function () {
                    // 需要判断组件是否 mounted
                    if (this.isMounted()) {
                        // 假如所有都选中了，将状态置为 foundAll
                        this.setState({
                            message: this.state.message === &#39;findMate&#39; ? &#39;findMate&#39; :
                                this.max === this.state.found ? &#39;foundAll&#39; : &#39;chooseTile&#39;,
                            tileStates: matched ? this.state.tileStates : _.extend(this.state.tileStates,
                                _.object([index, otherIndex], [&#39;unturned&#39;, &#39;unturned&#39;]))
                        });
                    }
                }.bind(this), 1500);
            }
        }
    },
    render: function () {
        // 使用 map 方式，将所有的卡片显示出来
        var tiles = this.props.words.map(function (word, i) {
            return (
                &lt;div key={i} onClick={_.partial(this.clickedTile, i)}&gt;
                    &lt;Tile word={word} status={this.state.tileStates[i]} /&gt;
                &lt;/div&gt;
            );
        }.bind(this));
        return (
            &lt;div&gt;
                &lt;button className=&#39;btn btn-default&#39; onClick={this.props.onEndGame}&gt;结束记忆&lt;/button&gt;
                &lt;Status found={this.state.found} max={this.max} message={this.state.message} /&gt;
                {tiles}
            &lt;/div&gt;
        );
    }
});

module.exports = Board;

&lt;h3 id=&#34;status:126e5f0c3267828479b5a765d781e066&#34;&gt;Status&lt;/h3&gt;

&lt;p&gt;新建文件&lt;code&gt;status.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;);

var Status = React.createClass({
    propTypes: {
        found: React.PropTypes.number.isRequired,
        max: React.PropTypes.number.isRequired,
        message: React.PropTypes.oneOf([
            &#39;chooseTile&#39;, &#39;findMate&#39;, &#39;wrong&#39;, &#39;foundMate&#39;, &#39;foundAll&#39;
        ]).isRequired
    },
    render: function () {
        var found = this.props.found,
            max = this.props.max,
            texts = {
                chooseTile: &#39;选择一张卡片！&#39;,
                findMate: &#39;现在我们来查找相对应的卡片！&#39;,
                wrong: &#39;很遗憾，这两张卡片不匹配！&#39;,
                foundMate: &#39;不错，他们是一对的！&#39;,
                foundAll: &#39;恭喜过关，你已经找到所有&#39; + max + &#39;对卡片了！&#39;
            };
        return (
            &lt;p&gt;({found}/{max})  {texts[this.props.message]}&lt;/p&gt;
        );
    }
});

module.exports = Status;

&lt;h3 id=&#34;tile:126e5f0c3267828479b5a765d781e066&#34;&gt;Tile&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新建文件&lt;code&gt;tile.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
var React = require(&#39;react&#39;);

var Tile = React.createClass({
    propTypes: {
        status: React.PropTypes.string.isRequired,
        word: React.PropTypes.string.isRequired
    },
    render: function () {
        return (
            &lt;div className={&#39;brick &#39; + this.props.status}&gt;
                &lt;div className=&#39;front&#39;&gt;&lt;i className=&#39;glyphicon glyphicon-question-sign&#39;&gt;&lt;/i&gt;&lt;/div&gt;
                &lt;div className=&#39;back&#39;&gt;{this.props.word}&lt;/div&gt;
            &lt;/div&gt;
        );
    }
});

module.exports = Tile;

&lt;ul&gt;
&lt;li&gt;修改文件&lt;code&gt;css/style.css&lt;/code&gt;，增加卡片需要的样式&lt;/li&gt;
&lt;/ul&gt;
@-webkit-keyframes wronganim {
    to {
        background-color: red;
    }
}

@-moz-keyframes wronganim {
    to {
        background-color: red;
    }
}

@keyframes wronganim {
    to {
        background-color: red;
    }
}

@-webkit-keyframes correctanim {
    to {
        background-color: green;
        color: white;
    }
}

@-moz-keyframes correctanim {
    to {
        background-color: green;
        color: white;
    }
}

@keyframes correctanim {
    to {
        background-color: green;
        color: white;
    }
}

.brick &gt; div {
    width: 80px;
    height: 80px;
    border: 1px solid black;
    text-align: center;
    line-height: 80px;
    font-size: 24px;
    -webkit-backface-visibility: hidden;
    -webkit-transition: -webkit-transform 0.3s linear;
    -moz-transition: -moz-transform 0.3s linear;
    transition: transform 0.3s linear;
    -webkit-transform-style: preserve-3d;
    transform-style: preserve-3d;
    position: absolute;
    overflow: hidden;
    border-radius: 5px;
    backface-visibility: hidden;
}

.brick &gt; .front {
    background-color: #AAA;
}

.brick, .brick div {
    user-select: none;
    cursor: pointer;
}

.brick {
    float: left;
    margin-right: 10px;
    margin-bottom: 10px;
    width: 80px;
    height: 80px;
}

.brick &gt; .back {
    -webkit-animation-duration: 0.5s;
    -webkit-animation-timing-function: ease;
    -webkit-animation-delay: 0.3s;
    -webkit-animation-iteration-count: 1;
    -webkit-animation-fill-mode: forwards;
    -moz-animation-duration: 0.5s;
    -moz-animation-timing-function: ease;
    -moz-animation-delay: 0.3s;
    -moz-animation-iteration-count: 1;
    -moz-animation-fill-mode: forwards;
    animation-duration: 0.5s;
    animation-timing-function: ease;
    animation-delay: 0.3s;
    animation-iteration-count: 1;
    animation-fill-mode: forwards;
}

.brick.wrong &gt; .back {
    -webkit-animation-name: wronganim;
    -moz-animation-name: wronganim;
    animation-name: wronganim;
}

.brick.correct &gt; .back {
    -webkit-animation-name: correctanim;
    -moz-animation-name: correctanim;
    animation-name: correctanim;
}

.brick &gt; .back {
    -webkit-transform: perspective(80px) rotateY(180deg) translate3d(0px, 0px, 2px);
    -moz-transform: perspective(80px) rotateY(180deg) translate3d(0px, 0px, 2px);
    transform: perspective(80px) rotateY(180deg) translate3d(0px, 0px, 2px);
}

.brick.correct &gt; .front, .brick.wrong &gt; .front, .brick.revealed &gt; .front {
    -webkit-transform: perspective(80px) rotateY(-180deg) translate3d(0px, 0px, 2px);
    -moz-transform: perspective(80px) rotateY(-180deg) translate3d(0px, 0px, 2px);
    transform: perspective(80px) rotateY(-180deg) translate3d(0px, 0px, 2px);
}

.brick.correct &gt; .back, .brick.wrong &gt; .back, .brick.revealed &gt; .back {
    -webkit-transform: perspective(80px) rotateY(0deg) translate3d(0px, 0px, 1px);
    -moz-transform: perspective(80px) rotateY(0deg) translate3d(0px, 0px, 1px);
    transform: perspective(80px) rotateY(0deg) translate3d(0px, 0px, 1px);
}

.front {
    font-size: 2em;
}

&lt;h3 id=&#34;app-js:126e5f0c3267828479b5a765d781e066&#34;&gt;app.js&lt;/h3&gt;

&lt;p&gt;创建好了我们所有的组件之后，我们需要将组件组合起来，创建文件&lt;code&gt;app.js&lt;/code&gt;&lt;/p&gt;
var React = require(&#39;react&#39;),
    Game = require(&#39;./game&#39;);

React.render(
    &lt;Game /&gt;,
    document.getElementById(&#39;app&#39;)
);

&lt;h3 id=&#34;index-html:126e5f0c3267828479b5a765d781e066&#34;&gt;index.html&lt;/h3&gt;

&lt;p&gt;新建文件：&lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&#34;utf-8&#34;&gt;
    &lt;title&gt;记忆游戏&lt;/title&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;css/style.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;nav class=&#34;navbar navbar-inverse navbar-fixed-top&#34;&gt;
    &lt;div class=&#34;container&#34;&gt;
        &lt;div class=&#34;navbar-header&#34;&gt;
            &lt;span class=&#34;navbar-brand&#34;&gt;记忆游戏&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/nav&gt;
&lt;div id=&#34;app&#34; class=&#34;container&#34;&gt;正在努力加载中……&lt;/div&gt;
&lt;script src=&#34;build/app.js&#34;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;h3 id=&#34;查看结果:126e5f0c3267828479b5a765d781e066&#34;&gt;查看结果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;开始编译监听 jsx 文件为 js&lt;/li&gt;
&lt;/ul&gt;
watchify -v -o build/app.js js/app.js

&lt;ul&gt;
&lt;li&gt;启用 http server&lt;/li&gt;
&lt;/ul&gt;
http-server -p 8888

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看界面 &lt;a href=&#34;http://localhost:8888/&#34;&gt;http://localhost:8888/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大功告成，开始开心的游戏吧！&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>开源所带来的——记 DBackup 4.0 发布和 Bootstrap Table 插件的开发</title>
      <link>http://blog.wenzhixin.net.cn/2014/11/08/bootstrap-table</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/11/08/bootstrap-table</guid>
      <description>

&lt;h3 id=&#34;源起:e5cac10725cb8ad4ca8dff8f0c5d6867&#34;&gt;源起&lt;/h3&gt;

&lt;p&gt;最最开始的时候，在写公司的考勤系统，系统的功能十分简单，只需要简单地查询数据和展示数据（无需增加、修改和删除），后台接口使用的是标准的 Restful API，例如接口&lt;code&gt;/api/url1&lt;/code&gt;返回这样的数组：&lt;/p&gt;
[
    {
        &#34;name&#34;: &#34;文翼&#34;,
        &#34;startTime&#34;: &#34;09:00&#34;,
        &#34;endTime&#34;: &#34;18:00&#34;
    }
]

&lt;p&gt;接口&lt;code&gt;/api/url2&lt;/code&gt;返回这样的数组：&lt;/p&gt;
[
    {
        &#34;name&#34;: &#34;文翼&#34;,
        &#34;job&#34;: &#34;Web开发工程师&#34;
    }
]

&lt;p&gt;一般的做法是遍历返回来的数据并对每一行的数据进行渲染为&lt;code&gt;tr&lt;/code&gt;，然后再&lt;code&gt;append&lt;/code&gt;到表格中。由于自己十分的“懒”，很多时候宁愿写出个工具（当然有时候可能花的时候会更多），也不想写重复的代码，做重复、无用的工作。现在系统有 5 个不同的接口，需要显示为 5 个不同的表格。要是能使用这样的代码，而无需使用 JavaScript 去对不同的 API 接口进行渲染组装，那该多省心省事：&lt;/p&gt;
&lt;table data-url=&#34;/api/url1&#34;&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;td data-field=&#34;name&#34;&gt;姓名&lt;/td&gt;
        &lt;td data-field=&#34;startTime&#34;&gt;上班时间&lt;/td&gt;
        &lt;td data-field=&#34;endTime&#34;&gt;下班时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
&lt;/table&gt;

&lt;table data-url=&#34;/api/url2&#34;&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;td data-field=&#34;name&#34;&gt;姓名&lt;/td&gt;
        &lt;td data-field=&#34;job&#34;&gt;工作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
&lt;/table&gt;

&lt;p&gt;可以看到，这样的话我们无需写一行 JavaScript 的代码就能实现我们想要的功能了。于是乎，Bootstrap Table 的 1.0.0 版本就这样面世了，只有最最简单的显示的功能，没有单选、多选、排序和分页等复杂的功能。&lt;/p&gt;

&lt;h3 id=&#34;开源和改善:e5cac10725cb8ad4ca8dff8f0c5d6867&#34;&gt;开源和改善&lt;/h3&gt;

&lt;p&gt;因为 Bootstrap Table 支持标准的 Restful API 接口，我便将其开源到 GitHub 上（6月份），并尝试着模仿 Bootstrap JavaScript Plugin 的文档说明，编写了全英文的文档（其实也没几个属性、方法和事件）。而在当时，由于公司最主要的产品 DBackup，并没有使用 Restful 接口 API，所以无法将其应用到自己的产品开发中。&lt;/p&gt;

&lt;p&gt;随着其他的产品也应用到 Bootstrap Table，我便加入了单选、多选、排序等功能。而在 GitHub 上，关注 Bootstrap Table 的人也多了起来，时不时有人给我提建议和一些新的功能，而大部分是很好的建议。并认真地考虑，加上了大部分觉得合理的功能。&lt;/p&gt;

&lt;p&gt;到发布 1.2.0 的时候（8月），我在想是不是应该应用到主要产品DBackup呢，只是要使用的话就得重构后台接口。不能浪费了，重构就重构，于是便开始为 DBackup 编写标准的 Restful API 文档，我们在开发的过程中往往习惯了根据后台接口，然后选择前端的实现。而 Bootstrap Table 是根据标准的 Restful API 来实现的，这反而能更好地使产品的接口更加规范化、文档化。&lt;/p&gt;

&lt;p&gt;那么，或许你会问，开源又带来了什么？&lt;/p&gt;

&lt;p&gt;在 GitHub 上，我们可以看到很多 Web 开源项目，而这些开源项目的工程师也乐于维护和改善这些开源项目，例如：Twitter 的 &lt;a href=&#34;https://github.com/twbs/bootstrap&#34;&gt;bootstrap&lt;/a&gt;，Facebook 的 &lt;a href=&#34;https://github.com/facebook/react&#34;&gt;react&lt;/a&gt;，阿里的 &lt;a href=&#34;https://github.com/seajs/seajs&#34;&gt;seajs&lt;/a&gt;，还有 &lt;a href=&#34;https://github.com/joyent/node&#34;&gt;node&lt;/a&gt;，&lt;a href=&#34;https://github.com/jashkenas/backbone&#34;&gt;backbone&lt;/a&gt;，&lt;a href=&#34;https://github.com/angular/angular.js&#34;&gt;angular.js&lt;/a&gt; 等等。&lt;/p&gt;

&lt;p&gt;我在签名档上写道：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I am making the world better by developing open-source JavaScript libraries.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;开源，就是为了使世界更加美好！哈哈，难道不是吗！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/08/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/08/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;时至今日，Bootstrap Table 项目已有 488 个 Star 和 109 个 Fork（分支），47 个 Pull Requests，支持 20 种语言（翻译），以及 4 个插件扩展。除了我自己，有很多热心开发者为其提交了很多有用的代码，插件扩展和建议。&lt;/p&gt;

&lt;p&gt;对于插件来说，因为开源，使其不断的完善和改进！&lt;/p&gt;

&lt;p&gt;对于公司产品来说，因为开源，越来越规范化和模块化！&lt;/p&gt;

&lt;p&gt;对于我来说，因为开源，自己的英文水平、代码规范化以及项目管理相关的方面也在不断提高！&lt;/p&gt;

&lt;h3 id=&#34;bootstrap-table-的强大之处:e5cac10725cb8ad4ca8dff8f0c5d6867&#34;&gt;Bootstrap Table 的强大之处&lt;/h3&gt;

&lt;p&gt;说了这么多，Bootstrap Table 的强大之处还是需要用个简单的例子来说明，除了上面用 html 的方式外，这里使用 JavaScript 的方式：&lt;/p&gt;

&lt;p&gt;定义 html（只需要一句话）：&lt;/p&gt;
&lt;table id=&#34;table&#34;&gt;&lt;/table&gt;

&lt;p&gt;使用：&lt;/p&gt;
$(&#39;#table&#39;).bootstrapTable({
    url: &#39;/api/url&#39;, // 接口 URL 地址
    cache: false, // 不缓存
    height: 400, // 设置高度，会启用固定表头的特性
    striped: true, // 隔行加亮
    pagination: true, // 开启分页功能
    pageSize: 50, // 设置默认分页为 50
    pageList: [10, 25, 50, 100, 200], // 自定义分页列表
    search: true, // 开启搜索功能
    showColumns: true, // 开启自定义列显示功能
    showRefresh: true, // 开启刷新功能
    minimumCountColumns: 2, // 设置最少显示列个数
    clickToSelect: true, // 单击行即可以选中
    sortName: &#39;name&#39;, // 设置默认排序为 name
    sortOrder: &#39;desc&#39;, // 设置排序为反序 desc
    smartDisplay: true, // 智能显示 pagination 和 cardview 等
    columns: [{ // 列设置
        field: &#39;state&#39;,
        checkbox: true // 使用复选框
    }, {
        field: &#39;id&#39;,
        title: &#39;Item ID&#39;,
        align: &#39;right&#39;,
        valign: &#39;bottom&#39;,
        sortable: true // 开启排序功能
    }, {
        field: &#39;name&#39;,
        title: &#39;Item Name&#39;,
        align: &#39;center&#39;,
        valign: &#39;middle&#39;,
        sortable: true,
        formatter: nameFormatter
    }, {
        field: &#39;price&#39;,
        title: &#39;Item Price&#39;,
        align: &#39;left&#39;,
        valign: &#39;top&#39;,
        sortable: true,
        formatter: priceFormatter,
        sorter: priceSorter
    }, {
        field: &#39;operate&#39;,
        title: &#39;Item Operate&#39;,
        align: &#39;center&#39;,
        valign: &#39;middle&#39;,
        clickToSelect: false,
        formatter: operateFormatter,
        events: operateEvents
    }]
});

&lt;p&gt;我们可以看到，通过简单的设置，就可以拥有强大的单选、多选、排序、分页，以及编辑、导出、过滤（扩展）等等的功能了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/08/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后，今天，我们的产品 DBackup 发布了 4.0 版本，其中一整个大模块已经全部重构为使用 Bootstrap Table 和标准的 Restful 接口。虽说距离全部还有一段时间和距离，但我坚信，Bootstrap Table 会越做越强大，产品也会越来越规范，越做越好用！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编写 WebStorm 实用工具</title>
      <link>http://blog.wenzhixin.net.cn/2014/11/04/webstorm_tools</link>
      <pubDate>Tue, 04 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/11/04/webstorm_tools</guid>
      <description>&lt;p&gt;在写代码的时候，很多时候（例如写 jQuery 插件）需要将 html 代码转换为 js 模板。例如将下面的 html 代码：&lt;/p&gt;
&lt;ul&gt;
    &lt;li class=&#34;item&#34;&gt;
        &lt;a href=&#34;#&#34;&gt;Item 1&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;放到 js 中：&lt;/p&gt;
var html = [
    &#39;&lt;ul&gt;&#39;,
        &#39;&lt;li class=&#34;item&#34;&gt;&#39;,
            &#39;&lt;a href=&#34;#&#34;&gt;Item 1&lt;/a&gt;&#39;,
        &#39;&lt;/li&gt;&#39;,
    &#39;&lt;/ul&gt;&#39;
];

&lt;p&gt;因为平时都是用 WebStorm 进行开发，就在想是否能够自定义快捷键实现这样的功能呢？
如按一下 &lt;code&gt;Ctrl + &#39;&lt;/code&gt; 切换为 js 代码，再按一次切换原来 html 的代码。先上想要的效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/04/gif.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了这样的想法，于是就开始尝试。&lt;/p&gt;

&lt;p&gt;首先尝试了自定义 Keymap （快捷键）的方式，发现行不通，因为只能自定义 WebStorm 本身已经定义好的 Action。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/04/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着看到 External Tools 可以定义外部的程序，Good，这样就可以使用外部的脚本语言来实现我想要的功能。
一开始是想使用 shell 来编写的，但是发现编写起来有些吃力，何不用自己熟悉的 nodejs 来写呢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/04/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是，便有了 &lt;code&gt;toggle-html-js-code&lt;/code&gt; 的雏形：&lt;/p&gt;
#! /usr/bin/node

var fs = require(&#39;fs&#39;);

// toggle-html-js-code $FilePath$ $SelectionStartLine$ $SelectionEndLine$

var filePath = process.argv[2],
    startLine = +process.argv[3],
    endLine = +process.argv[4],
    type = &#39;html&#39;,
    content,
    lines,
    i;

content = fs.readFileSync(filePath).toString();
lines = content.split(&#39;\n&#39;);

if (/&#39;.*&#39;,?/.test(lines[startLine - 1])) {
    type = &#39;js&#39;;
}

for (i = startLine - 1; i &lt; endLine; i++) {
    lines[i] = type === &#39;html&#39; ?
        html2js(lines[i], i !== startLine - 1 &amp;&amp; i === endLine - 1) :
        js2html(lines[i], i !== startLine - 1 &amp;&amp; i === endLine - 1);
}
fs.writeFileSync(filePath, lines.join(&#39;\n&#39;));


// tools

function html2js(str, lastLine) {
    if (!/([\S^&#39;].*[\S^&#39;])/.test(str)) {
        return str;
    }
    return str.replace(/([\S^&#39;].*[\S^&#39;])/, &#39;\&#39;\$1\&#39;&#39; + (lastLine ? &#39;&#39; : &#39;,&#39;));
}

function js2html(str, lastLine) {
    if (lastLine) {
        if (!/&#39;(.*)&#39;/.test(str)) {
            return str;
        }
        return str.replace(/&#39;(.*)&#39;/, &#39;\$1&#39;);
    } else {
        if (!/&#39;(.*)&#39;,/.test(str)) {
            return str;
        }
        return str.replace(/&#39;(.*)&#39;,/, &#39;\$1&#39;);
    }
}

&lt;p&gt;最后，再到 Keymap 中设置快捷键为 &lt;code&gt;Ctrl + &#39;&lt;/code&gt; 就大功告成了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/04/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/11/04/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PS：上面的代码已经实现了自己想要的功能，但可能还需要进行完善优化，本文只是对自己想法进行了尝试并实现，或许可以用插件的方式来实现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>chrome 浏览器 console 面板直接使用 JSON 数据进行调试错误问题</title>
      <link>http://blog.wenzhixin.net.cn/2014/11/02/chrome_console_error</link>
      <pubDate>Sun, 02 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/11/02/chrome_console_error</guid>
      <description>&lt;p&gt;今天在微博上看到小鱼在问：&lt;a href=&#34;https://gist.github.com/sofish/c250881989aaa10c029d&#34;&gt;https://gist.github.com/sofish/c250881989aaa10c029d&lt;/a&gt; 为什么会出错，看了下之前就有遇到过这个问题，特意整理记录下。&lt;/p&gt;

&lt;p&gt;是想直接 copy json 数据到 console 面板进行调试，但是竟然报错了。然后特意对比了下，奇怪的是为什么 &lt;code&gt;{a: &amp;quot;b&amp;quot;}&lt;/code&gt; 是输出 &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;，而 &lt;code&gt;{&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;}&lt;/code&gt; 输出却是 &lt;code&gt;Uncaught SyntaxError: Unexpected token :&lt;/code&gt;，why?&lt;/p&gt;

&lt;p&gt;后面就研究了下，可以看到源码 &lt;a href=&#34;https://code.google.com/p/webkit-mirror/source/browse/Source/WebCore/inspector/InjectedScriptSource.js?r=ed19c0a99ddb564e317bb7363d481c2693ffb5fd#333&#34;&gt;InjectedScriptSource.js&lt;/a&gt; 中实现 console 是通过下面的方式：&lt;/p&gt;
expression = &#34;with ((window &amp;&amp; window.console &amp;&amp; window.console._commandLineAPI) || {}) {\n&#34; + expression + &#34;\n}&#34;;
eval(expression);

&lt;p&gt;当我们在 &lt;code&gt;console&lt;/code&gt; 面板下直接输入 &lt;code&gt;{a: &amp;quot;b&amp;quot;}&lt;/code&gt; 时，相当于执行：&lt;/p&gt;
eval(&#34;with ((window &amp;&amp; window.console &amp;&amp; window.console._commandLineAPI) || {}) {\n{a: \&#34;b\&#34;}\n}&#34;); // &#34;b&#34;

&lt;p&gt;而 &lt;code&gt;{&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;}&lt;/code&gt; 相当于执行：&lt;/p&gt;
eval(&#34;with ((window &amp;&amp; window.console &amp;&amp; window.console._commandLineAPI) || {}) {\n{\&#34;a\&#34;: \&#34;b\&#34;}\n}&#34;); // Uncaught SyntaxError: Unexpected token :

&lt;p&gt;因为 &lt;code&gt;with&lt;/code&gt; 这里的 &lt;code&gt;{{ ... }}&lt;/code&gt; 被忽略成了 &lt;code&gt;{}&lt;/code&gt;，例如：&lt;/p&gt;
with (window) {{{{a:&#34;b&#34;}}}}; // window.a = &#34;b&#34;;

with (window) {&#34;a&#34;:&#34;b&#34;}; // error!!!

&lt;p&gt;后面想直接 copy json 到 console 中进行调试的时候，加上：&lt;/p&gt;
var obj = {&#34;status&#34;:&#34;error&#34;,&#34;error&#34;:{&#34;msg&#34;:&#34;\u6b64\u997f\u5355\u5df2\u6295\u8bc9&#34;,&#34;code&#34;:23}}; // undefined

&lt;p&gt;就OK了，但是这样还得输入多一次 obj，干脆酱紫：&lt;/p&gt;
}0,{&#34;status&#34;:&#34;error&#34;,&#34;error&#34;:{&#34;msg&#34;:&#34;\u6b64\u997f\u5355\u5df2\u6295\u8bc9&#34;,&#34;code&#34;:23} // Object {status: &#34;error&#34;, error: Object}

&lt;p&gt;还有其他的一些比较有趣的，例如输入：&lt;/p&gt;
{} // undefined

( // Uncaught SyntaxError: Unexpected token }

}{ // undefined

}!{ // false

}!!{ // true

}+{ // NaN
</description>
    </item>
    
    <item>
      <title>如何不用 eval 的方式通过字符串调用 JavaScript 的方法</title>
      <link>http://blog.wenzhixin.net.cn/2014/10/03/call_string_function</link>
      <pubDate>Fri, 03 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/10/03/call_string_function</guid>
      <description>&lt;p&gt;由于 &lt;a href=&#34;https://github.com/wenzhixin/bootstrap-table&#34;&gt;bootstrap-table&lt;/a&gt; 插件需要支持&lt;code&gt;data-name=&amp;quot;functionName&amp;quot;&lt;/code&gt;的方式，所以在实现的过程中使用了&lt;code&gt;eval&lt;/code&gt;的方法。我们知道，在 JavaScript 中，&lt;code&gt;eval&lt;/code&gt;是丑陋的，在&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/eval&#34;&gt;MDN&lt;/a&gt;中提到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Obsolete&lt;/p&gt;

&lt;p&gt;This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们通过&lt;code&gt;eval&lt;/code&gt;执行字符串代码，例如：&lt;/p&gt;
eval(&#34;var x = &#39;Hello from eval!&#39;;&#34;);
console.log(x);

&lt;p&gt;然而，&lt;code&gt;eval&lt;/code&gt;会带来一些意想不到的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安全性问题：你的字符串可能会被注入其他的命令或者第三方脚本。&lt;/li&gt;
&lt;li&gt;可调试问题：很难去调试错误信息。&lt;/li&gt;
&lt;li&gt;压缩问题：程序不会对字符串进行最小化压缩。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不幸的是，在实际的开发中，&lt;code&gt;eval&lt;/code&gt;经常会被滥用，例如解析 JSON 字符串，虽然使用&lt;code&gt;eval&lt;/code&gt;可以正常工作，但是我们应该尽量避免使用它，例如使用&lt;code&gt;JSON.parse&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;那么，我们如何才能不用 eval 的方式通过字符串调用 JavaScript 的方法呢？&lt;/p&gt;

&lt;p&gt;首先，假如我们有一个字符串名称的方法：&lt;/p&gt;
// function we want to run
var func = &#39;runMe&#39;;

function runMe() {
    // do something
}

&lt;p&gt;一个好的解决方法那就是我们可以通过&lt;code&gt;window&lt;/code&gt;对象，在调用方法之前我们对其进行检查：&lt;/p&gt;
// find function
var fn = window[func]; // runMe

// is a function?
if (typeof fn === &#39;function&#39;) {
    fn();
}

&lt;p&gt;更多的时候，我们的方法是有一系列的参数的，例如我们存放到数组中，这个我们只需要简单的执行&lt;code&gt;apply&lt;/code&gt;方法即可：&lt;/p&gt;
// function name and parameters to pass
var func = &#39;runMe&#39;;
var args = [1, 2, 3];

// find function
var fn = window[func]; // runMe

// is a function?
if (typeof fn === &#39;function&#39;) {
    fn.apply(null, args);
}

&lt;p&gt;到此，我们知道了不用 eval 的方式通过字符串调用 JavaScript 的方法，是更安全、容易进行调试、运行更快的方法。&lt;/p&gt;

&lt;p&gt;最后，将其封装成了一个工具函数：&lt;/p&gt;
var calculateFunctionValue = function (func, args, defaultValue) {
    if (typeof func === &#39;string&#39;) {
        // support obj.func1.func2
        var fs = func.split(&#39;.&#39;);

        if (fs.length &gt; 1) {
            func = window;
            $.each(fs, function (i, f) {
                func = func[f];
            });
        } else {
            func = window[func];
        }
    }
    if (typeof func === &#39;function&#39;) {
        return func.apply(null, args);
    }
    return defaultValue;
};

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对字符串对象，也同样的方法处理。而对于字符串数组，则使用类似：&lt;/p&gt;
&#39;[5, 10, 20, 50, 100, 200]&#39;.replace(/, /g, &#39;,&#39;).slice(1, -1).split(&#39;,&#39;);
</description>
    </item>
    
    <item>
      <title>使用 JavaScript 转换数据单位</title>
      <link>http://blog.wenzhixin.net.cn/2014/09/03/convert_size_using_javascript</link>
      <pubDate>Wed, 03 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/09/03/convert_size_using_javascript</guid>
      <description>&lt;p&gt;我们知道，千字节是一个计量单位，虽然从字面上理解代表着1000，但是专业术语&lt;code&gt;kilobyte&lt;/code&gt;在计算机科学和信息技术等领域有两种含义，分别代表1024（2&lt;sup&gt;10&lt;/sup&gt;）和1000（10&lt;sup&gt;3&lt;/sup&gt;）。&lt;/p&gt;

&lt;p&gt;例如，当我们提到“数据传输速度”和“硬盘存储空间”的时候，千字节代表1000（10&lt;sup&gt;3&lt;/sup&gt;）；而提到内存或者CPU高速缓存容量的时候，千字节代表1024（2&lt;sup&gt;10&lt;/sup&gt;），这是因为在这里是按照字节码地址存储的。&lt;/p&gt;

&lt;p&gt;在实际应用中，我们经常需要将字节码转换为KB、MB、GB等等，这里使用JavaScript对字节码进行转换：&lt;/p&gt;
function bytesToSize(bytes) {
    if (bytes === 0) return &#39;0 B&#39;;
    var k = 1000, // or 1024
        sizes = [&#39;B&#39;, &#39;KB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;],
        i = Math.floor(Math.log(bytes) / Math.log(k));

   return (bytes / Math.pow(k, i)).toPrecision(3) + &#39; &#39; + sizes[i];
}
</description>
    </item>
    
    <item>
      <title>通过 vim 编辑网页文本输入框</title>
      <link>http://blog.wenzhixin.net.cn/2014/08/30/edit_text_gvim</link>
      <pubDate>Sat, 30 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/08/30/edit_text_gvim</guid>
      <description>

&lt;p&gt;对于文本编辑和编写代码，我们常常会用到 vim，使用 vim 的好处在这里就不多说了。那么能不能在浏览器中的文本输入框中也使用 vim 来编辑呢，编辑完之后再自动保存回去？答案当然可以！&lt;/p&gt;

&lt;p&gt;使用这种方式，我们可以将编写的内容随时保存到临时文件中，或者可以打开已经保存的文件中继续编辑。&lt;/p&gt;

&lt;h3 id=&#34;使用的环境:36b5f6c6e268d0329acc55e45482e8aa&#34;&gt;使用的环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;浏览器：chrome&lt;/li&gt;
&lt;li&gt;操作系统：Ubuntu 14.04&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装和使用:36b5f6c6e268d0329acc55e45482e8aa&#34;&gt;安装和使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 gvim：&lt;/p&gt;
sudo apt-get install vim-gnome&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载后台脚本：&lt;/p&gt;
# mkdir ~/bin
cd ~/bin
wget http://opencoder.net/edit-server
chmod +x edit-server&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑配置后台脚本信息：&lt;/p&gt;
vi edit-server
our $REQUIRE_AUTH = 1; # 将这里改为 our $REQUIRE_AUTH = 0;
our $PORT = 8888; # 将这里改为自己没有用到的端口，例如 our $PORT = 8123;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;增加自动启动后台服务到&lt;code&gt;.profile&lt;/code&gt;中：&lt;/p&gt;
vi ~/.profile
$HOME/bin/edit-server &amp;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装浏览器插件 &lt;a href=&#34;https://chrome.google.com/webstore/detail/ppoadiihggafnhokfkpphojggcdigllp&#34;&gt;TextAid&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置 TextAid：
安装完成后，焦点在需要输入的文本框时，浏览器 URL 输入框会出现
&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/08/30/2.png&#34; alt=&#34;&#34; /&gt;
右击点击选项，将 URL 设置为 &lt;a href=&#34;http://127.0.0.1:8123&#34;&gt;http://127.0.0.1:8123&lt;/a&gt; （对应自己设置的端号）
&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/08/30/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开始使用：
在你需要编辑文本输入框时，点击浏览器 URL 出现的图标即可弹出 gvim 的输入框，然后开始享受你的 vim 编辑器吧。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;附：设置 gvim 配色和字体。&lt;/p&gt;
vi ~/.gvimrc
colorscheme slate
set guifont=Ubuntu\ Mono\ 12
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>表格固定表头的问题和解决方案</title>
      <link>http://blog.wenzhixin.net.cn/2014/08/10/fixed_table</link>
      <pubDate>Sun, 10 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/08/10/fixed_table</guid>
      <description>

&lt;p&gt;在写插件&lt;a href=&#34;https://github.com/wenzhixin/bootstrap-table&#34;&gt;bootstrap table&lt;/a&gt;的时候，当数据过多的时候，需要对表格的 &lt;code&gt;thead&lt;/code&gt;进行固定，然后滚动表格的&lt;code&gt;tbody&lt;/code&gt;。但是在实际的操作上，花了很多的时间在这个问题上，到现在也没有找到完美的解决方案，在这里记录下这个问题。&lt;/p&gt;

&lt;h3 id=&#34;方案一-1-0-6:073e6e06b9c5ef2c807de43d88ce5036&#34;&gt;方案一(&amp;lt;=1.0.6)&lt;/h3&gt;

&lt;p&gt;最开始的解决方法是通过设置&lt;code&gt;th&lt;/code&gt;中的&lt;code&gt;div&lt;/code&gt;的 &lt;code&gt;position&lt;/code&gt;为&lt;code&gt;absolute&lt;/code&gt;，从而达到固定表头的效果：&lt;/p&gt;
&lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt;
            &lt;div class=&#34;th-inner&#34; style=&#34;position: absolute; width: 197px;&#34;&gt;
                Item ID
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th&gt;
            &lt;div class=&#34;th-inner&#34; style=&#34;position: absolute; width: 346px;&#34;&gt;
                Item Name
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th&gt;
            &lt;div class=&#34;th-inner&#34; style=&#34;position: absolute; width: 255px;&#34;&gt;
                Item Price
            &lt;/div&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
&lt;/thead&gt;

&lt;p&gt;这里的&lt;code&gt;width&lt;/code&gt;，是需要通过对&lt;code&gt;tbody&lt;/code&gt;的第一行元素的宽度进行计算出来的。&lt;/p&gt;

&lt;p&gt;这个方法虽然可行，但是会出现如：
&lt;a href=&#34;https://github.com/wenzhixin/bootstrap-table/issues/34&#34;&gt;https://github.com/wenzhixin/bootstrap-table/issues/34&lt;/a&gt; 这个问题所描述的当表头文字过长，而表格内容过短，就会显示 &amp;hellip; 的问题，显然这种方法是存在很大的问题的。&lt;/p&gt;

&lt;h3 id=&#34;方案二-1-1-2:073e6e06b9c5ef2c807de43d88ce5036&#34;&gt;方案二(&amp;lt;=1.1.2)&lt;/h3&gt;

&lt;p&gt;参考了很多方法，方案二使用 jQuery 的`&lt;code&gt;clone&lt;/code&gt;方法生成两个相同的 table，并将第一个 table 的&lt;code&gt;tbody&lt;/code&gt;和第二个 table 的&lt;code&gt;thead&lt;/code&gt;隐藏起来，这里需要将第一个 table 的&lt;code&gt;overflow&lt;/code&gt;设置为&lt;code&gt;hidden&lt;/code&gt;，第二个 table 的&lt;code&gt;margin-top&lt;/code&gt;设置为第一个 table 表头的负高度。&lt;/p&gt;

&lt;p&gt;这个方案适应所有的浏览器，但是会出现如：
&lt;a href=&#34;https://github.com/wenzhixin/bootstrap-table/issues/52&#34;&gt;https://github.com/wenzhixin/bootstrap-table/issues/52&lt;/a&gt; 这个问题所描述的当使用浏览器自带的搜索时，会出现两处相同的内容，并且出现在表头处（overflow 会自动调整），显然这种方法会对用户造成困扰和极大的影响用户体验。&lt;/p&gt;

&lt;h3 id=&#34;方案三:073e6e06b9c5ef2c807de43d88ce5036&#34;&gt;方案三&lt;/h3&gt;

&lt;p&gt;方案三参考了许多 GitHub 上其他实现固定表头的 jQuery 插件，例如：&lt;a href=&#34;http://www.fixedheadertable.com/&#34;&gt;fixedheadertable&lt;/a&gt;和&lt;a href=&#34;http://datatables.net/extensions/fixedheader/&#34;&gt;datatables&lt;/a&gt;，跟方案二有点类似，他们都是通过 clone 表格的&lt;code&gt;thead&lt;/code&gt;，然后将其固定住，并根据原来 table 的每一列的宽度重新计算设置固定表头的宽度，关键代码如下：&lt;/p&gt;
this.$body.find(&#39;tr:first-child:not(.no-records-found) &gt; *&#39;).each(function(i) {
    that.$header_.find(&#39;div.fht-cell&#39;).eq(i).width($(this).innerWidth());
});

&lt;p&gt;这个办法是可行的，但是发现了一个小瑕疵，那就是使用 firefox （其他浏览器都正常使用）的时候，即使表头的宽度和原来表格的宽度一模一样，有时候会渲染的不是很完美（刚刚提到的其他插件也存在这个问题），如下图显示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/08/10/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PS: 或许有更好的实现方法，不断改进。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解 JavaScript 中的 Array.prototype.slice.apply(arguments)</title>
      <link>http://blog.wenzhixin.net.cn/2014/08/03/slice_arguments</link>
      <pubDate>Sun, 03 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/08/03/slice_arguments</guid>
      <description>&lt;p&gt;假如你是一个 JavaScript 开发者，你可能见到过 Array.prototype.slice.apply(arguments) 这样的用法，然后你会问，这么写是什么意思呢？&lt;/p&gt;

&lt;p&gt;这个语法其实不难理解，只是它有些不好看。Array 是 JavaScript 的基本类型，你可以使用 Array.prototype 获取它的属性值，在这里我假设你已经了解了 prototype 的概念。&lt;/p&gt;

&lt;p&gt;slice 是 JavaScript 的一个方法，用于选取一个数组的一部分数据，并返回一个新的数组。它可以接收两个参数，startIndex（必选）和 endIndex。因此：&lt;/p&gt;
var a = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;];
a.slice(1,2);

&lt;p&gt;将返回数组 [&amp;ldquo;b&amp;rdquo;]，它包含 a 数组从 1 到 2 之间元素。而：&lt;/p&gt;
var a = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;];
a.slice(1);

&lt;p&gt;则会返回数组 [“b”, “c”]，它包含 a 数组从 1 到最后一个元素之间元素。&lt;/p&gt;

&lt;p&gt;这里的 a 是个数组，那么变量 arguments 呢？&lt;/p&gt;

&lt;p&gt;众所周知，当你调用 JavaScript 的函数的时候，会创建一个隐藏的名为 arguments 的参数，你是不是觉得它就是一个数组呢？答案是否定的，它是一个对象，但是与数组类似。&lt;/p&gt;
function f () {
  return arguments;
}

f(&#34;1&#34;, &#34;2&#34;) instanceof Array;

&lt;p&gt;这里，你会得到 FALSE 的结果，就是说我们不能像平常一样使用 Array 的函数，例如：push，pop，slice等等这些。但是我想使用这些方法，应该怎么办呢？&lt;/p&gt;

&lt;p&gt;我们可以使用 Array.prototype.slice.apply(arguments) 对参数进行转换为真正的 Array。这里我们使用了 JavaScript 的 apply 方法，通过这个方法可以更好的了解 JavaScript 中调用函数的另一种方法。该方法将 slice 应用到第一个参数 arguments 中，并返回一个数组。&lt;/p&gt;
Array.prototype.slice.apply(f(&#34;1&#34;, &#34;2&#34;)) instanceof Array;

&lt;p&gt;现在可以看到这里返回 TRUE 的结果！！&lt;/p&gt;

&lt;p&gt;PS：在 ECMAScript5 中，我们只需要直接调用 arguments.slice() 即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>设置 viewport 实现定宽网页 WebApp 下布局自适应</title>
      <link>http://blog.wenzhixin.net.cn/2014/08/01/viewport_mobile</link>
      <pubDate>Fri, 01 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/08/01/viewport_mobile</guid>
      <description>&lt;p&gt;一般来说，我们实现布局自适应可以有以下几种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用流动布局（fluid grid）&lt;/li&gt;
&lt;li&gt;根据屏幕大小选择加载不同的CSS&lt;/li&gt;
&lt;li&gt;使用 CSS 的@media规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的介绍，可以参考&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html&#34;&gt;自适应网页设计（Responsive Web Design）&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;p&gt;这里介绍的是如何让定宽网页在 WebApp 下（或者手机浏览器）实现自适应。例如，我们设计了一套宽度为 640px 的小页面，主要是用于手机查看，但是手机屏幕分辨率实在太多了，要适应每台手机，应该怎么办呢？&lt;/p&gt;

&lt;p&gt;首先，我们在 head 中加入：&lt;/p&gt;
&lt;head&gt;
&lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, user-scalable=no&#34;&gt;
&lt;/head&gt;

&lt;p&gt;这里表示 viewport 的宽度为匹配设备屏幕的宽度，且禁用缩放。涉及到两个概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag&#34;&gt;viewport 元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;devicePixelRatio：设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于 iphone 手机和 android 4.0 以上的手机支持修改 viewport 的 width 来改变页面的缩放情况，因此我们&lt;strong&gt;可以将 width 指定为页面设计的宽度&lt;/strong&gt;，如此一来，你的页面正好充满 viewport 并全屏显示，而不会缩放。例如：&lt;/p&gt;
&lt;meta name=&#34;viewport&#34; content=&#34;width=640px, user-scalable=no&#34;&gt;

&lt;p&gt;但是对于 android 4.0 以下的手机，不支持设置 viewport 的 width，但是我们&lt;strong&gt;可以设置 Android 的另一参数target-densitydpi，从而达到相同的目的&lt;/strong&gt;，计算 target-densitydpi 的公式如下：&lt;/p&gt;
target-densitydpi = UI-width / device-width * window.devicePixelRatio * 160;
  //UI-width ：WebApp布局宽度
  //device-width ：屏幕分辨率宽度

&lt;p&gt;于是，&lt;strong&gt;最终解决方案&lt;/strong&gt;如下：&lt;/p&gt;
&lt;meta name=&#34;viewport&#34; content=&#34;target-densitydpi=device-dpi, width=640px, user-scalable=no&#34;&gt;
$(function () {
	var DEFAULT_WIDTH = 640, // 页面的默认宽度
		ua = navigator.userAgent.toLowerCase(), // 根据 user agent 的信息获取浏览器信息
		deviceWidth = window.screen.width, // 设备的宽度
		devicePixelRatio = window.devicePixelRatio || 1, // 物理像素和设备独立像素的比例，默认为1
		targetDensitydpi;

	// Android4.0以下手机不支持viewport的width，需要设置target-densitydpi
	if (ua.indexOf(&#34;android&#34;) !== -1 &amp;&amp; parseFloat(ua.slice(ua.indexOf(&#34;android&#34;)+8)) &lt; 4) {
    	targetDensitydpi = DEFAULT_WIDTH / deviceWidth * devicePixelRatio * 160;
    	$(&#39;meta[name=&#34;viewport&#34;]&#39;).attr(&#39;content&#39;, &#39;target-densitydpi=&#39; + targetDensitydpi +
    			&#39;, width=device-width, user-scalable=no&#39;);
    }

	// TODO: 其他手机需要特殊处理的在下面
});

&lt;p&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目前只测试 android 和 ios/ipad 手机&lt;/li&gt;
&lt;li&gt;android 下使用 firefox 无法检测出 android 的版本，因此只能忽略 firefox&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;ps: 理论上可以利用枚举的方式将通用的手机分辨率记录起来，从而达到适应所有机型的效果。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>IE8 文件上传问题分析小记</title>
      <link>http://blog.wenzhixin.net.cn/2014/07/30/ie8_file_problem</link>
      <pubDate>Wed, 30 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/07/30/ie8_file_problem</guid>
      <description>&lt;p&gt;先吐槽一番，IE 浏览器让前端开发人员又恨又郁闷，但是没有办法，谁让中国如此多的用户呢。很多时候，一个简单的问题，可能需要花上大半天的时间才能解决，足够浪费时间的了，故在此记录下。&lt;/p&gt;

&lt;p&gt;首先，问题是这样的：&lt;strong&gt;在 IE8 下选择上传文件无任何反应，其他浏览器使用正常。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而同事实现的方法是，将文件选择框隐藏起来，然后通过点击一个按钮来选择上传文件并触发事件：&lt;/p&gt;
&lt;form class=&#34;hidden&#34; action=&#34;url&#34; method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
    &lt;input id=&#34;file&#34; type=&#34;file&#34; name=&#34;file&#34;&gt;
&lt;/form&gt;
&lt;a href=&#34;javascript:void(0)&#34; class=&#34;btn&#34;&gt;Upload&lt;/a&gt;
$(&#39;#button&#39;).live(&#39;click&#39;, function () {
    $(&#39;#file&#39;).trigger(&#39;click&#39;);
});
$(&#39;#file&#39;).live(&#39;change&#39;, function () {
    // 调用开始上传方法
});

&lt;p&gt;上面的&lt;code&gt;button&lt;/code&gt;和&lt;code&gt;file&lt;/code&gt;分别是按钮和文件选择框的 ID。&lt;code&gt;live&lt;/code&gt;是旧版 jQuery 绑定事件的方法，现在已经废弃了。&lt;/p&gt;

&lt;p&gt;查阅相关资料，得知这是 jQuery 的一个 bug，&lt;strong&gt;IE8 file 使用&lt;code&gt;live&lt;/code&gt;方法不能触发 change 事件&lt;/strong&gt;，所以将代码改为：&lt;/p&gt;
$(&#39;#button&#39;).click(function () {
    $(&#39;#file&#39;).trigger(&#39;click&#39;);
});
$(&#39;#file&#39;).change(function () {
    // 调用开始上传方法
});

&lt;p&gt;改完之后是可以触发 change 事件了，但是得到这样的一个错误：&lt;code&gt;Access is denied&lt;/code&gt;。原因如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;IE doesn&amp;rsquo;t allow manipulation of the type=&amp;ldquo;file&amp;rdquo; input element from javascript due to security reasons. Setting the filename or invoking a click event to show the browser dialog will result in an &amp;ldquo;Access is denied&amp;rdquo; error on the form submit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;使用手动触发点击事件来弹出文件选择框会出现没有权限的错误。&lt;/strong&gt;于是，我又对代码进行了改进：&lt;/p&gt;
&lt;style&gt;
.pr {
    position: relative;
}
#file {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    right: 0;
    opacity: 0;
    filter: alpha(opacity=0);
}
&lt;/style&gt;
&lt;form action=&#34;url&#34; method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
    &lt;a href=&#34;javascript:void(0)&#34; class=&#34;button pr&#34;&gt;
        Upload
        &lt;input id=&#34;file&#34; type=&#34;file&#34; name=&#34;file&#34;&gt;
    &lt;/a&gt;
&lt;/form&gt;

&lt;p&gt;注意到 css 样式，我将 file 的透明度设置为 0，放置在按钮上，当点击按钮的时候，实际上点击的是 file，并且删除了按钮的&lt;code&gt;click&lt;/code&gt;事件，从而解决了手动触发 click 事件所导致的&lt;code&gt;Access is denied&lt;/code&gt;的问题。&lt;/p&gt;

&lt;p&gt;但是接着我又遇到了问题，因为后台是使用 php 的，我们知道，php 用于处理文件上传使用的是 &lt;code&gt;$_FILES&lt;/code&gt;，在其他浏览器都正常，但是 IE8 选择文件就会出现空的情况。网上说要设置：&lt;/p&gt;

&lt;p&gt;form：&lt;/p&gt;
enctype=&#34;multipart/form-data&#34;

&lt;p&gt;php.ini：&lt;/p&gt;
file_uploads = On; sounds like you already did this
post_max_size = 8M; change this higher if needed
upload_max_file_size = 8M; change this higher if needed

&lt;p&gt;通过检查，都已经设置的了，那就郁闷了，为什么死活没有数据呢？&lt;/p&gt;

&lt;p&gt;于是我用了最简单的方法，写了个只有文件上传的demo作为对比，结果是能获取到&lt;code&gt;$_FILES&lt;/code&gt;的数据的！！！&lt;/p&gt;

&lt;p&gt;问题的原因居然是因为 &lt;strong&gt;file 不能嵌套在 a 标签下&lt;/strong&gt;，不然会导致获取不到数据，这个又是 IE8 的 bug，问题到此告一段落，却也浪费了我大半天的时间，最后的解决方案如下：&lt;/p&gt;
&lt;style&gt;
.pr {
    position: relative;
}
.dil {
    display: inline-block;
}
#file {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    right: 0;
    opacity: 0;
    filter: alpha(opacity=0);
}
&lt;/style&gt;
&lt;form action=&#34;url&#34; method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
    &lt;span class=&#34;pr dil&#34;&gt;
        &lt;a href=&#34;javascript:void(0)&#34; class=&#34;btn&#34;&gt;Upload&lt;/a&gt;
        &lt;input id=&#34;file&#34; type=&#34;file&#34; name=&#34;file&#34;&gt;
    &lt;/span&gt;
&lt;/form&gt;
</description>
    </item>
    
    <item>
      <title>读《Backbone.js 实战》</title>
      <link>http://blog.wenzhixin.net.cn/2014/07/06/backbone_book</link>
      <pubDate>Sun, 06 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/07/06/backbone_book</guid>
      <description>

&lt;p&gt;Backbone 是一个轻量级 JavaScript 的 MVC 框架，配合 Underscore 这个依赖库，我们可以打造出强大的 MVC 应用程序。其实很早就用到 Backbone + Underscore 进行网站和应用程序的开发了，只是国内一直没有相关的书籍，这次看到《Backbone.js 实战》，就买下了。现在对书籍的要求越来越高，对于这本书也认认真真的看了一遍，这里写一下读书的笔记和自己的一些看法。&lt;/p&gt;

&lt;h3 id=&#34;第一章:9665a217439f92224574aec4c262bcea&#34;&gt;第一章&lt;/h3&gt;

&lt;p&gt;是对 Backbone 的介绍以及通过第一个 hello,backbone! 的小应用来介绍如何使用 backbone 进行开发，和其他一些书差不多都是以 hello, world 开篇。&lt;/p&gt;

&lt;h3 id=&#34;第二章:9665a217439f92224574aec4c262bcea&#34;&gt;第二章&lt;/h3&gt;

&lt;p&gt;主要介绍依赖库 Underscore 的常见函数的使用方法，包括了集合、数组、函数、对象和功能：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/07/06/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.wenzhixin.net.cn/2014/07/06/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我觉得像这些函数的介绍在官方的文档中都是有的，而且也有简单的例子，像这种介绍应该可以完善下的，例如加入一些扩展或者对比什么的。如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sortBy 函数默认是返回一个按升序排序的副本列表，那我想反序呢？（p17）&lt;/li&gt;
&lt;li&gt;delay 函数类似于 setTimeout 方法，那为什么还要设计这个函数，它们的区别又是什么？（p22）&lt;/li&gt;
&lt;li&gt;实例代码 &lt;code&gt;return s ? n + &amp;quot;, 先生&amp;quot; : n + &amp;quot;, 女士&amp;quot;;&lt;/code&gt;是否可以改成&lt;code&gt;return n + &amp;quot;, &amp;quot; + s ? &amp;quot;先生&amp;quot; : &amp;quot;女士&amp;quot;&lt;/code&gt;更简短一些呢？（p23）&lt;/li&gt;
&lt;li&gt;defaults 函数与 jQuery 中的 extend 有什么区别？（p26）&lt;/li&gt;
&lt;li&gt;has 函数与 hasOwnProperty 函数有什么区别？（p27）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrap a 标签按钮使用 prop 方法</title>
      <link>http://blog.wenzhixin.net.cn/2014/06/18/a_prop_problem</link>
      <pubDate>Wed, 18 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/06/18/a_prop_problem</guid>
      <description>

&lt;h3 id=&#34;问题:a28454daa0e071303e4565ef461d5dfa&#34;&gt;问题&lt;/h3&gt;

&lt;p&gt;将 jQuery 从 1.5.2 升级到 1.7.2 之后，统一将&lt;code&gt;attr(&#39;disabled&#39;, &#39;disabled&#39;)&lt;/code&gt;改为&lt;code&gt;prop(&#39;disabled&#39;, true)&lt;/code&gt;，将&lt;code&gt;attr(&#39;disabled&#39;, &#39;&#39;)&lt;/code&gt;改为&lt;code&gt;prop(&#39;disabled&#39;, false)&lt;/code&gt;。由于使用了 bootstrap，所以很多按钮都是 a 标签按钮，如：&lt;/p&gt;
&lt;a class=&#34;btn&#34; href=&#34;javascript:void(0)&#34;&gt;button&lt;/a&gt;

&lt;p&gt;当对 a 标签使用 prop 的时候，并没有禁用按钮。&lt;/p&gt;

&lt;h3 id=&#34;原因:a28454daa0e071303e4565ef461d5dfa&#34;&gt;原因&lt;/h3&gt;

&lt;p&gt;从&lt;a href=&#34;http://wenzhixin.net.cn/2013/08/12/disable_link&#34;&gt;Bootstrap 禁用 a 按钮&lt;/a&gt;一文中，我们知道禁用 ａ 标签的按钮是利用 css，而通过&lt;a href=&#34;http://wenzhixin.net.cn/2013/05/24/jquery_attr_prop&#34;&gt;jQuery 中 attr() 和 prop() 方法的区别&lt;/a&gt;我们知道对于 a 标签应该使用&lt;code&gt;attr(&#39;disabled&#39;, true)&lt;/code&gt;。由于项目比较庞大，修改的地方也比较多，需要先判断这个按钮是否为 a 标签，那么有没有更好的办法呢？&lt;/p&gt;

&lt;h3 id=&#34;解决:a28454daa0e071303e4565ef461d5dfa&#34;&gt;解决&lt;/h3&gt;

&lt;p&gt;通过统一处理 jQuery 的函数来解决这个问题，代码如下：&lt;/p&gt;
(function() {
    var fn = {
        attr: jQuery.fn.attr,
        prop: jQuery.fn.prop
    };

    jQuery.fn.prop = function() {
        var value,
            args = Array.prototype.slice.apply(arguments);

        if (!this.length &amp;&amp; args.length === 1) {
            return undefined;
        }
        this.each(function() {
            if (args.length === 1) {
                value = fn[$(this).is(&#39;a&#39;) ? &#39;attr&#39; : &#39;prop&#39;].apply($(this), args);
            } else {
                fn[$(this).is(&#39;a&#39;) ? &#39;attr&#39; : &#39;prop&#39;].apply($(this), args);
            }
        });
        return typeof value === &#39;undefined&#39; ? this : value;
    };
})();

&lt;p&gt;在这里，我们对原来的 prop 函数进行了预处理，假如是 a 标签则使用 attr 方式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 Backbone.js 中自定义 fetch 错误处理</title>
      <link>http://blog.wenzhixin.net.cn/2014/06/14/backbone_custom_fetch_errors</link>
      <pubDate>Sat, 14 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.wenzhixin.net.cn/2014/06/14/backbone_custom_fetch_errors</guid>
      <description>&lt;p&gt;Backbone 作为 JavaScript MVC 框架的一个优势是它可以通过监听事件来处理事情。但是根据 Collection 的相关&lt;a href=&#34;http://backbonejs.org/#Collection&#34;&gt;文档&lt;/a&gt;，可以看到：当你使用&lt;code&gt;fetch&lt;/code&gt;方法来进行 Ajax 请求的时候，假如发生了错误，并没有触发任何事件。虽然，可以通过&lt;code&gt;collection.fetch({error: handleError});&lt;/code&gt;的方法来处理错误，但是假如我们的 Collection 一多，那就不太好办了，很难做到统一处理错误，并且每个地方都要加上对错误的处理。&lt;/p&gt;

&lt;p&gt;查看 fetch 的源码：&lt;/p&gt;
fetch: function(options) {
  options = options ? _.clone(options) : {};
  if (options.parse === void 0) options.parse = true;
  var success = options.success;
  var collection = this;
  options.success = function(resp) {
    var method = options.reset ? &#39;reset&#39; : &#39;set&#39;;
    collection[method](resp, options);
    if (success) success(collection, resp, options);
    collection.trigger(&#39;sync&#39;, collection, resp, options);
  };
  wrapError(this, options);
  return this.sync(&#39;read&#39;, this, options);
}

&lt;p&gt;我们可以通过修改这一方法，从而达到自定义错误处理的效果，代码如下：&lt;/p&gt;
var appView = new AppView(),
    fetch = Backbone.Collection.prototype.fetch;

Backbone.Collection.prototype.fetch = function(options) {
    var self = this,
        opts = {
            error: function(collection, res) {
                self.trigger(&#39;fetch.error&#39;);　// trigger custom event
                if (options &amp;&amp; options.error) {
                    options.error(arguments);
                    return;
                }
                if (res.status === 401) {
                    appView.showLogin();
                } else {
                    appView.showError(res.status);
                }
            }
        };

    // Combine options and custom handlers, apply to fetch prototype.
    (_.bind(fetch, this, _.extend({}, options, opts)))();
};

&lt;p&gt;可以看到我们重写了&lt;code&gt;Backbone.Collection.prototype.fetch&lt;/code&gt;方法，并自定义了&lt;code&gt;fetch.error&lt;/code&gt;事件，方便进行监听处理。最重要的是我们不用修改之前的任何代码，在这里对错误进行了统一的处理，当&lt;code&gt;status code&lt;/code&gt;为 401 时，我们跳转到登录页面，其他则显示错误信息。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>